// @ts-nocheck
/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/zod@4.1.12/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const e = Object.freeze({ status: "aborted" }); function t(e, t, n) { function i(n, i) { var r; Object.defineProperty(n, "_zod", { value: n._zod ?? {}, enumerable: !1 }), (r = n._zod).traits ?? (r.traits = new Set), n._zod.traits.add(e), t(n, i); for (const e in o.prototype) e in n || Object.defineProperty(n, e, { value: o.prototype[e].bind(n) }); n._zod.constr = o, n._zod.def = i } const r = n?.Parent ?? Object; class a extends r { } function o(e) { var t; const r = n?.Parent ? new a : this; i(r, e), (t = r._zod).deferred ?? (t.deferred = []); for (const e of r._zod.deferred) e(); return r } return Object.defineProperty(a, "name", { value: e }), Object.defineProperty(o, "init", { value: i }), Object.defineProperty(o, Symbol.hasInstance, { value: t => !!(n?.Parent && t instanceof n.Parent) || t?._zod?.traits?.has(e) }), Object.defineProperty(o, "name", { value: e }), o } const n = Symbol("zod_brand"); class i extends Error { constructor() { super("Encountered Promise during synchronous parse. Use .parseAsync() instead.") } } class r extends Error { constructor(e) { super(`Encountered unidirectional transform during encode: ${e}`), this.name = "ZodEncodeError" } } const a = {}; function o(e) { return e && Object.assign(a, e), a } function s(e) { const t = Object.values(e).filter((e => "number" == typeof e)); return Object.entries(e).filter((([e, n]) => -1 === t.indexOf(+e))).map((([e, t]) => t)) } function u(e, t = "|") { return e.map((e => U(e))).join(t) } function c(e, t) { return "bigint" == typeof t ? t.toString() : t } function l(e) { return { get value() { { const t = e(); return Object.defineProperty(this, "value", { value: t }), t } } } } function d(e) { return null == e } function m(e) { const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length; return e.slice(t, n) } function p(e, t) { const n = (e.toString().split(".")[1] || "").length, i = t.toString(); let r = (i.split(".")[1] || "").length; if (0 === r && /\d?e-\d?/.test(i)) { const e = i.match(/\d?e-(\d?)/); e?.[1] && (r = Number.parseInt(e[1])) } const a = n > r ? n : r; return Number.parseInt(e.toFixed(a).replace(".", "")) % Number.parseInt(t.toFixed(a).replace(".", "")) / 10 ** a } const f = Symbol("evaluating"); function v(e, t, n) { let i; Object.defineProperty(e, t, { get() { if (i !== f) return void 0 === i && (i = f, i = n()), i }, set(n) { Object.defineProperty(e, t, { value: n }) }, configurable: !0 }) } function g(e, t, n) { Object.defineProperty(e, t, { value: n, writable: !0, enumerable: !0, configurable: !0 }) } function h(...e) { const t = {}; for (const n of e) { const e = Object.getOwnPropertyDescriptors(n); Object.assign(t, e) } return Object.defineProperties({}, t) } function $(e) { return JSON.stringify(e) } const y = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => { }; function _(e) { return "object" == typeof e && null !== e && !Array.isArray(e) } const b = l((() => { if ("undefined" != typeof navigator && navigator?.userAgent?.includes("Cloudflare")) return !1; try { return new Function(""), !0 } catch (e) { return !1 } })); function k(e) { if (!1 === _(e)) return !1; const t = e.constructor; if (void 0 === t) return !0; const n = t.prototype; return !1 !== _(n) && !1 !== Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") } function I(e) { return k(e) ? { ...e } : Array.isArray(e) ? [...e] : e } const w = new Set(["string", "number", "symbol"]), z = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]); function S(e) { return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } function x(e, t, n) { const i = new e._zod.constr(t ?? e._zod.def); return t && !n?.parent || (i._zod.parent = e), i } function O(e) { const t = e; if (!t) return {}; if ("string" == typeof t) return { error: () => t }; if (void 0 !== t?.message) { if (void 0 !== t?.error) throw new Error("Cannot specify both `message` and `error` params"); t.error = t.message } return delete t.message, "string" == typeof t.error ? { ...t, error: () => t.error } : t } function U(e) { return "bigint" == typeof e ? e.toString() + "n" : "string" == typeof e ? `"${e}"` : `${e}` } function j(e) { return Object.keys(e).filter((t => "optional" === e[t]._zod.optin && "optional" === e[t]._zod.optout)) } const N = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, D = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] }; function Z(e, t) { const n = e._zod.def; return x(e, h(e._zod.def, { get shape() { const e = {}; for (const i in t) { if (!(i in n.shape)) throw new Error(`Unrecognized key: "${i}"`); t[i] && (e[i] = n.shape[i]) } return g(this, "shape", e), e }, checks: [] })) } function P(e, t) { const n = e._zod.def, i = h(e._zod.def, { get shape() { const i = { ...e._zod.def.shape }; for (const e in t) { if (!(e in n.shape)) throw new Error(`Unrecognized key: "${e}"`); t[e] && delete i[e] } return g(this, "shape", i), i }, checks: [] }); return x(e, i) } function E(e, t) { if (!k(t)) throw new Error("Invalid input to extend: expected a plain object"); const n = e._zod.def.checks; if (n && n.length > 0) throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead."); const i = h(e._zod.def, { get shape() { const n = { ...e._zod.def.shape, ...t }; return g(this, "shape", n), n }, checks: [] }); return x(e, i) } function T(e, t) { if (!k(t)) throw new Error("Invalid input to safeExtend: expected a plain object"); const n = { ...e._zod.def, get shape() { const n = { ...e._zod.def.shape, ...t }; return g(this, "shape", n), n }, checks: e._zod.def.checks }; return x(e, n) } function A(e, t) { const n = h(e._zod.def, { get shape() { const n = { ...e._zod.def.shape, ...t._zod.def.shape }; return g(this, "shape", n), n }, get catchall() { return t._zod.def.catchall }, checks: [] }); return x(e, n) } function L(e, t, n) { const i = h(t._zod.def, { get shape() { const i = t._zod.def.shape, r = { ...i }; if (n) for (const t in n) { if (!(t in i)) throw new Error(`Unrecognized key: "${t}"`); n[t] && (r[t] = e ? new e({ type: "optional", innerType: i[t] }) : i[t]) } else for (const t in i) r[t] = e ? new e({ type: "optional", innerType: i[t] }) : i[t]; return g(this, "shape", r), r }, checks: [] }); return x(t, i) } function C(e, t, n) { const i = h(t._zod.def, { get shape() { const i = t._zod.def.shape, r = { ...i }; if (n) for (const t in n) { if (!(t in r)) throw new Error(`Unrecognized key: "${t}"`); n[t] && (r[t] = new e({ type: "nonoptional", innerType: i[t] })) } else for (const t in i) r[t] = new e({ type: "nonoptional", innerType: i[t] }); return g(this, "shape", r), r }, checks: [] }); return x(t, i) } function R(e, t = 0) { if (!0 === e.aborted) return !0; for (let n = t; n < e.issues.length; n++)if (!0 !== e.issues[n]?.continue) return !0; return !1 } function F(e, t) { return t.map((t => { var n; return (n = t).path ?? (n.path = []), t.path.unshift(e), t })) } function J(e) { return "string" == typeof e ? e : e?.message } function M(e, t, n) { const i = { ...e, path: e.path ?? [] }; if (!e.message) { const r = J(e.inst?._zod.def?.error?.(e)) ?? J(t?.error?.(e)) ?? J(n.customError?.(e)) ?? J(n.localeError?.(e)) ?? "Invalid input"; i.message = r } return delete i.inst, delete i.continue, t?.reportInput || delete i.input, i } function W(e) { return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown" } function G(e) { return Array.isArray(e) ? "array" : "string" == typeof e ? "string" : "unknown" } function V(...e) { const [t, n, i] = e; return "string" == typeof t ? { message: t, code: "custom", input: n, inst: i } : { ...t } } function K(e) { const t = atob(e), n = new Uint8Array(t.length); for (let e = 0; e < t.length; e++)n[e] = t.charCodeAt(e); return n } function B(e) { let t = ""; for (let n = 0; n < e.length; n++)t += String.fromCharCode(e[n]); return btoa(t) } var X = Object.freeze({ __proto__: null, assertEqual: function (e) { return e }, assertNotEqual: function (e) { return e }, assertIs: function (e) { }, assertNever: function (e) { throw new Error }, assert: function (e) { }, getEnumValues: s, joinValues: u, jsonStringifyReplacer: c, cached: l, nullish: d, cleanRegex: m, floatSafeRemainder: p, defineLazy: v, objectClone: function (e) { return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e)) }, assignProp: g, mergeDefs: h, cloneDef: function (e) { return h(e._zod.def) }, getElementAtPath: function (e, t) { return t ? t.reduce(((e, t) => e?.[t]), e) : e }, promiseAllObject: function (e) { const t = Object.keys(e), n = t.map((t => e[t])); return Promise.all(n).then((e => { const n = {}; for (let i = 0; i < t.length; i++)n[t[i]] = e[i]; return n })) }, randomString: function (e = 10) { const t = "abcdefghijklmnopqrstuvwxyz"; let n = ""; for (let i = 0; i < e; i++)n += t[Math.floor(26 * Math.random())]; return n }, esc: $, captureStackTrace: y, isObject: _, allowsEval: b, isPlainObject: k, shallowClone: I, numKeys: function (e) { let t = 0; for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++; return t }, getParsedType: e => { const t = typeof e; switch (t) { case "undefined": return "undefined"; case "string": return "string"; case "number": return Number.isNaN(e) ? "nan" : "number"; case "boolean": return "boolean"; case "function": return "function"; case "bigint": return "bigint"; case "symbol": return "symbol"; case "object": return Array.isArray(e) ? "array" : null === e ? "null" : e.then && "function" == typeof e.then && e.catch && "function" == typeof e.catch ? "promise" : "undefined" != typeof Map && e instanceof Map ? "map" : "undefined" != typeof Set && e instanceof Set ? "set" : "undefined" != typeof Date && e instanceof Date ? "date" : "undefined" != typeof File && e instanceof File ? "file" : "object"; default: throw new Error(`Unknown data type: ${t}`) } }, propertyKeyTypes: w, primitiveTypes: z, escapeRegex: S, clone: x, normalizeParams: O, createTransparentProxy: function (e) { let t; return new Proxy({}, { get: (n, i, r) => (t ?? (t = e()), Reflect.get(t, i, r)), set: (n, i, r, a) => (t ?? (t = e()), Reflect.set(t, i, r, a)), has: (n, i) => (t ?? (t = e()), Reflect.has(t, i)), deleteProperty: (n, i) => (t ?? (t = e()), Reflect.deleteProperty(t, i)), ownKeys: n => (t ?? (t = e()), Reflect.ownKeys(t)), getOwnPropertyDescriptor: (n, i) => (t ?? (t = e()), Reflect.getOwnPropertyDescriptor(t, i)), defineProperty: (n, i, r) => (t ?? (t = e()), Reflect.defineProperty(t, i, r)) }) }, stringifyPrimitive: U, optionalKeys: j, NUMBER_FORMAT_RANGES: N, BIGINT_FORMAT_RANGES: D, pick: Z, omit: P, extend: E, safeExtend: T, merge: A, partial: L, required: C, aborted: R, prefixIssues: F, unwrapMessage: J, finalizeIssue: M, getSizableOrigin: W, getLengthableOrigin: G, issue: V, cleanEnum: function (e) { return Object.entries(e).filter((([e, t]) => Number.isNaN(Number.parseInt(e, 10)))).map((e => e[1])) }, base64ToUint8Array: K, uint8ArrayToBase64: B, base64urlToUint8Array: function (e) { const t = e.replace(/-/g, "+").replace(/_/g, "/"); return K(t + "=".repeat((4 - t.length % 4) % 4)) }, uint8ArrayToBase64url: function (e) { return B(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") }, hexToUint8Array: function (e) { const t = e.replace(/^0x/, ""); if (t.length % 2 != 0) throw new Error("Invalid hex string length"); const n = new Uint8Array(t.length / 2); for (let e = 0; e < t.length; e += 2)n[e / 2] = Number.parseInt(t.slice(e, e + 2), 16); return n }, uint8ArrayToHex: function (e) { return Array.from(e).map((e => e.toString(16).padStart(2, "0"))).join("") }, Class: class { constructor(...e) { } } }); const q = (e, t) => { e.name = "$ZodError", Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }), Object.defineProperty(e, "issues", { value: t, enumerable: !1 }), e.message = JSON.stringify(t, c, 2), Object.defineProperty(e, "toString", { value: () => e.message, enumerable: !1 }) }, Y = t("$ZodError", q), H = t("$ZodError", q, { Parent: Error }); function Q(e, t = e => e.message) { const n = {}, i = []; for (const r of e.issues) r.path.length > 0 ? (n[r.path[0]] = n[r.path[0]] || [], n[r.path[0]].push(t(r))) : i.push(t(r)); return { formErrors: i, fieldErrors: n } } function ee(e, t = e => e.message) { const n = { _errors: [] }, i = e => { for (const r of e.issues) if ("invalid_union" === r.code && r.errors.length) r.errors.map((e => i({ issues: e }))); else if ("invalid_key" === r.code) i({ issues: r.issues }); else if ("invalid_element" === r.code) i({ issues: r.issues }); else if (0 === r.path.length) n._errors.push(t(r)); else { let e = n, i = 0; for (; i < r.path.length;) { const n = r.path[i]; i === r.path.length - 1 ? (e[n] = e[n] || { _errors: [] }, e[n]._errors.push(t(r))) : e[n] = e[n] || { _errors: [] }, e = e[n], i++ } } }; return i(e), n } function te(e, t = e => e.message) { const n = { errors: [] }, i = (e, r = []) => { var a, o; for (const s of e.issues) if ("invalid_union" === s.code && s.errors.length) s.errors.map((e => i({ issues: e }, s.path))); else if ("invalid_key" === s.code) i({ issues: s.issues }, s.path); else if ("invalid_element" === s.code) i({ issues: s.issues }, s.path); else { const e = [...r, ...s.path]; if (0 === e.length) { n.errors.push(t(s)); continue } let i = n, u = 0; for (; u < e.length;) { const n = e[u], r = u === e.length - 1; "string" == typeof n ? (i.properties ?? (i.properties = {}), (a = i.properties)[n] ?? (a[n] = { errors: [] }), i = i.properties[n]) : (i.items ?? (i.items = []), (o = i.items)[n] ?? (o[n] = { errors: [] }), i = i.items[n]), r && i.errors.push(t(s)), u++ } } }; return i(e), n } function ne(e) { const t = [], n = e.map((e => "object" == typeof e ? e.key : e)); for (const e of n) "number" == typeof e ? t.push(`[${e}]`) : "symbol" == typeof e ? t.push(`[${JSON.stringify(String(e))}]`) : /[^\w$]/.test(e) ? t.push(`[${JSON.stringify(e)}]`) : (t.length && t.push("."), t.push(e)); return t.join("") } function ie(e) { const t = [], n = [...e.issues].sort(((e, t) => (e.path ?? []).length - (t.path ?? []).length)); for (const e of n) t.push(`✖ ${e.message}`), e.path?.length && t.push(`  → at ${ne(e.path)}`); return t.join("\n") } const re = e => (t, n, r, a) => { const s = r ? Object.assign(r, { async: !1 }) : { async: !1 }, u = t._zod.run({ value: n, issues: [] }, s); if (u instanceof Promise) throw new i; if (u.issues.length) { const t = new (a?.Err ?? e)(u.issues.map((e => M(e, s, o())))); throw y(t, a?.callee), t } return u.value }, ae = re(H), oe = e => async (t, n, i, r) => { const a = i ? Object.assign(i, { async: !0 }) : { async: !0 }; let s = t._zod.run({ value: n, issues: [] }, a); if (s instanceof Promise && (s = await s), s.issues.length) { const t = new (r?.Err ?? e)(s.issues.map((e => M(e, a, o())))); throw y(t, r?.callee), t } return s.value }, se = oe(H), ue = e => (t, n, r) => { const a = r ? { ...r, async: !1 } : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, a); if (s instanceof Promise) throw new i; return s.issues.length ? { success: !1, error: new (e ?? Y)(s.issues.map((e => M(e, a, o())))) } : { success: !0, data: s.value } }, ce = ue(H), le = e => async (t, n, i) => { const r = i ? Object.assign(i, { async: !0 }) : { async: !0 }; let a = t._zod.run({ value: n, issues: [] }, r); return a instanceof Promise && (a = await a), a.issues.length ? { success: !1, error: new e(a.issues.map((e => M(e, r, o())))) } : { success: !0, data: a.value } }, de = le(H), me = e => (t, n, i) => { const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return re(e)(t, n, r) }, pe = me(H), fe = e => (t, n, i) => re(e)(t, n, i), ve = fe(H), ge = e => async (t, n, i) => { const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return oe(e)(t, n, r) }, he = ge(H), $e = e => async (t, n, i) => oe(e)(t, n, i), ye = $e(H), _e = e => (t, n, i) => { const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return ue(e)(t, n, r) }, be = _e(H), ke = e => (t, n, i) => ue(e)(t, n, i), Ie = ke(H), we = e => async (t, n, i) => { const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return le(e)(t, n, r) }, ze = we(H), Se = e => async (t, n, i) => le(e)(t, n, i), xe = Se(H), Oe = /^[cC][^\s-]{8,}$/, Ue = /^[0-9a-z]+$/, je = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Ne = /^[0-9a-vA-V]{20}$/, De = /^[A-Za-z0-9]{27}$/, Ze = /^[a-zA-Z0-9_-]{21}$/, Pe = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Ee = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Te = e => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, Ae = Te(4), Le = Te(6), Ce = Te(7), Re = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Fe = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, Je = Fe; function Me() { return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u") } const We = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ge = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Ve = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Ke = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Be = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Xe = /^[A-Za-z0-9_-]*$/, qe = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, Ye = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, He = /^\+(?:[0-9]){6,14}[0-9]$/, Qe = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", et = new RegExp(`^${Qe}$`); function tt(e) { const t = "(?:[01]\\d|2[0-3]):[0-5]\\d"; return "number" == typeof e.precision ? -1 === e.precision ? `${t}` : 0 === e.precision ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?` } function nt(e) { return new RegExp(`^${tt(e)}$`) } function it(e) { const t = tt({ precision: e.precision }), n = ["Z"]; e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)"); const i = `${t}(?:${n.join("|")})`; return new RegExp(`^${Qe}T(?:${i})$`) } const rt = e => new RegExp(`^${e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*"}$`), at = /^-?\d+n?$/, ot = /^-?\d+$/, st = /^-?\d+(?:\.\d+)?/, ut = /^(?:true|false)$/i, ct = /^null$/i, lt = /^undefined$/i, dt = /^[^A-Z]*$/, mt = /^[^a-z]*$/, pt = /^[0-9a-fA-F]*$/; function ft(e, t) { return new RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`) } function vt(e) { return new RegExp(`^[A-Za-z0-9_-]{${e}}$`) } const gt = ft(22, "=="), ht = vt(22), $t = ft(27, "="), yt = vt(27), _t = ft(43, "="), bt = vt(43), kt = ft(64, ""), It = vt(64), wt = ft(86, "=="), zt = vt(86); var St = Object.freeze({ __proto__: null, cuid: Oe, cuid2: Ue, ulid: je, xid: Ne, ksuid: De, nanoid: Ze, duration: Pe, extendedDuration: /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, guid: Ee, uuid: Te, uuid4: Ae, uuid6: Le, uuid7: Ce, email: Re, html5Email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rfc5322Email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, unicodeEmail: Fe, idnEmail: Je, browserEmail: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, emoji: Me, ipv4: We, ipv6: Ge, cidrv4: Ve, cidrv6: Ke, base64: Be, base64url: Xe, hostname: qe, domain: Ye, e164: He, date: et, time: nt, datetime: it, string: rt, bigint: at, integer: ot, number: st, boolean: ut, null: ct, undefined: lt, lowercase: dt, uppercase: mt, hex: pt, md5_hex: /^[0-9a-fA-F]{32}$/, md5_base64: gt, md5_base64url: ht, sha1_hex: /^[0-9a-fA-F]{40}$/, sha1_base64: $t, sha1_base64url: yt, sha256_hex: /^[0-9a-fA-F]{64}$/, sha256_base64: _t, sha256_base64url: bt, sha384_hex: /^[0-9a-fA-F]{96}$/, sha384_base64: kt, sha384_base64url: It, sha512_hex: /^[0-9a-fA-F]{128}$/, sha512_base64: wt, sha512_base64url: zt }); const xt = t("$ZodCheck", ((e, t) => { var n; e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []) })), Ot = { number: "number", bigint: "bigint", object: "date" }, Ut = t("$ZodCheckLessThan", ((e, t) => { xt.init(e, t); const n = Ot[typeof t.value]; e._zod.onattach.push((e => { const n = e._zod.bag, i = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY; t.value < i && (t.inclusive ? n.maximum = t.value : n.exclusiveMaximum = t.value) })), e._zod.check = i => { (t.inclusive ? i.value <= t.value : i.value < t.value) || i.issues.push({ origin: n, code: "too_big", maximum: t.value, input: i.value, inclusive: t.inclusive, inst: e, continue: !t.abort }) } })), jt = t("$ZodCheckGreaterThan", ((e, t) => { xt.init(e, t); const n = Ot[typeof t.value]; e._zod.onattach.push((e => { const n = e._zod.bag, i = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY; t.value > i && (t.inclusive ? n.minimum = t.value : n.exclusiveMinimum = t.value) })), e._zod.check = i => { (t.inclusive ? i.value >= t.value : i.value > t.value) || i.issues.push({ origin: n, code: "too_small", minimum: t.value, input: i.value, inclusive: t.inclusive, inst: e, continue: !t.abort }) } })), Nt = t("$ZodCheckMultipleOf", ((e, t) => { xt.init(e, t), e._zod.onattach.push((e => { var n; (n = e._zod.bag).multipleOf ?? (n.multipleOf = t.value) })), e._zod.check = n => { if (typeof n.value != typeof t.value) throw new Error("Cannot mix number and bigint in multiple_of check."); ("bigint" == typeof n.value ? n.value % t.value === BigInt(0) : 0 === p(n.value, t.value)) || n.issues.push({ origin: typeof n.value, code: "not_multiple_of", divisor: t.value, input: n.value, inst: e, continue: !t.abort }) } })), Dt = t("$ZodCheckNumberFormat", ((e, t) => { xt.init(e, t), t.format = t.format || "float64"; const n = t.format?.includes("int"), i = n ? "int" : "number", [r, a] = N[t.format]; e._zod.onattach.push((e => { const i = e._zod.bag; i.format = t.format, i.minimum = r, i.maximum = a, n && (i.pattern = ot) })), e._zod.check = o => { const s = o.value; if (n) { if (!Number.isInteger(s)) return void o.issues.push({ expected: i, format: t.format, code: "invalid_type", continue: !1, input: s, inst: e }); if (!Number.isSafeInteger(s)) return void (s > 0 ? o.issues.push({ input: s, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: i, continue: !t.abort }) : o.issues.push({ input: s, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: i, continue: !t.abort })) } s < r && o.issues.push({ origin: "number", input: s, code: "too_small", minimum: r, inclusive: !0, inst: e, continue: !t.abort }), s > a && o.issues.push({ origin: "number", input: s, code: "too_big", maximum: a, inst: e }) } })), Zt = t("$ZodCheckBigIntFormat", ((e, t) => { xt.init(e, t); const [n, i] = D[t.format]; e._zod.onattach.push((e => { const r = e._zod.bag; r.format = t.format, r.minimum = n, r.maximum = i })), e._zod.check = r => { const a = r.value; a < n && r.issues.push({ origin: "bigint", input: a, code: "too_small", minimum: n, inclusive: !0, inst: e, continue: !t.abort }), a > i && r.issues.push({ origin: "bigint", input: a, code: "too_big", maximum: i, inst: e }) } })), Pt = t("$ZodCheckMaxSize", ((e, t) => { var n; xt.init(e, t), (n = e._zod.def).when ?? (n.when = e => { const t = e.value; return !d(t) && void 0 !== t.size }), e._zod.onattach.push((e => { const n = e._zod.bag.maximum ?? Number.POSITIVE_INFINITY; t.maximum < n && (e._zod.bag.maximum = t.maximum) })), e._zod.check = n => { const i = n.value; i.size <= t.maximum || n.issues.push({ origin: W(i), code: "too_big", maximum: t.maximum, inclusive: !0, input: i, inst: e, continue: !t.abort }) } })), Et = t("$ZodCheckMinSize", ((e, t) => { var n; xt.init(e, t), (n = e._zod.def).when ?? (n.when = e => { const t = e.value; return !d(t) && void 0 !== t.size }), e._zod.onattach.push((e => { const n = e._zod.bag.minimum ?? Number.NEGATIVE_INFINITY; t.minimum > n && (e._zod.bag.minimum = t.minimum) })), e._zod.check = n => { const i = n.value; i.size >= t.minimum || n.issues.push({ origin: W(i), code: "too_small", minimum: t.minimum, inclusive: !0, input: i, inst: e, continue: !t.abort }) } })), Tt = t("$ZodCheckSizeEquals", ((e, t) => { var n; xt.init(e, t), (n = e._zod.def).when ?? (n.when = e => { const t = e.value; return !d(t) && void 0 !== t.size }), e._zod.onattach.push((e => { const n = e._zod.bag; n.minimum = t.size, n.maximum = t.size, n.size = t.size })), e._zod.check = n => { const i = n.value, r = i.size; if (r === t.size) return; const a = r > t.size; n.issues.push({ origin: W(i), ...a ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size }, inclusive: !0, exact: !0, input: n.value, inst: e, continue: !t.abort }) } })), At = t("$ZodCheckMaxLength", ((e, t) => { var n; xt.init(e, t), (n = e._zod.def).when ?? (n.when = e => { const t = e.value; return !d(t) && void 0 !== t.length }), e._zod.onattach.push((e => { const n = e._zod.bag.maximum ?? Number.POSITIVE_INFINITY; t.maximum < n && (e._zod.bag.maximum = t.maximum) })), e._zod.check = n => { const i = n.value; if (i.length <= t.maximum) return; const r = G(i); n.issues.push({ origin: r, code: "too_big", maximum: t.maximum, inclusive: !0, input: i, inst: e, continue: !t.abort }) } })), Lt = t("$ZodCheckMinLength", ((e, t) => { var n; xt.init(e, t), (n = e._zod.def).when ?? (n.when = e => { const t = e.value; return !d(t) && void 0 !== t.length }), e._zod.onattach.push((e => { const n = e._zod.bag.minimum ?? Number.NEGATIVE_INFINITY; t.minimum > n && (e._zod.bag.minimum = t.minimum) })), e._zod.check = n => { const i = n.value; if (i.length >= t.minimum) return; const r = G(i); n.issues.push({ origin: r, code: "too_small", minimum: t.minimum, inclusive: !0, input: i, inst: e, continue: !t.abort }) } })), Ct = t("$ZodCheckLengthEquals", ((e, t) => { var n; xt.init(e, t), (n = e._zod.def).when ?? (n.when = e => { const t = e.value; return !d(t) && void 0 !== t.length }), e._zod.onattach.push((e => { const n = e._zod.bag; n.minimum = t.length, n.maximum = t.length, n.length = t.length })), e._zod.check = n => { const i = n.value, r = i.length; if (r === t.length) return; const a = G(i), o = r > t.length; n.issues.push({ origin: a, ...o ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length }, inclusive: !0, exact: !0, input: n.value, inst: e, continue: !t.abort }) } })), Rt = t("$ZodCheckStringFormat", ((e, t) => { var n, i; xt.init(e, t), e._zod.onattach.push((e => { const n = e._zod.bag; n.format = t.format, t.pattern && (n.patterns ?? (n.patterns = new Set), n.patterns.add(t.pattern)) })), t.pattern ? (n = e._zod).check ?? (n.check = n => { t.pattern.lastIndex = 0, t.pattern.test(n.value) || n.issues.push({ origin: "string", code: "invalid_format", format: t.format, input: n.value, ...t.pattern ? { pattern: t.pattern.toString() } : {}, inst: e, continue: !t.abort }) }) : (i = e._zod).check ?? (i.check = () => { }) })), Ft = t("$ZodCheckRegex", ((e, t) => { Rt.init(e, t), e._zod.check = n => { t.pattern.lastIndex = 0, t.pattern.test(n.value) || n.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: n.value, pattern: t.pattern.toString(), inst: e, continue: !t.abort }) } })), Jt = t("$ZodCheckLowerCase", ((e, t) => { t.pattern ?? (t.pattern = dt), Rt.init(e, t) })), Mt = t("$ZodCheckUpperCase", ((e, t) => { t.pattern ?? (t.pattern = mt), Rt.init(e, t) })), Wt = t("$ZodCheckIncludes", ((e, t) => { xt.init(e, t); const n = S(t.includes), i = new RegExp("number" == typeof t.position ? `^.{${t.position}}${n}` : n); t.pattern = i, e._zod.onattach.push((e => { const t = e._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(i) })), e._zod.check = n => { n.value.includes(t.includes, t.position) || n.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: t.includes, input: n.value, inst: e, continue: !t.abort }) } })), Gt = t("$ZodCheckStartsWith", ((e, t) => { xt.init(e, t); const n = new RegExp(`^${S(t.prefix)}.*`); t.pattern ?? (t.pattern = n), e._zod.onattach.push((e => { const t = e._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(n) })), e._zod.check = n => { n.value.startsWith(t.prefix) || n.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: t.prefix, input: n.value, inst: e, continue: !t.abort }) } })), Vt = t("$ZodCheckEndsWith", ((e, t) => { xt.init(e, t); const n = new RegExp(`.*${S(t.suffix)}$`); t.pattern ?? (t.pattern = n), e._zod.onattach.push((e => { const t = e._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(n) })), e._zod.check = n => { n.value.endsWith(t.suffix) || n.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: t.suffix, input: n.value, inst: e, continue: !t.abort }) } })); function Kt(e, t, n) { e.issues.length && t.issues.push(...F(n, e.issues)) } const Bt = t("$ZodCheckProperty", ((e, t) => { xt.init(e, t), e._zod.check = e => { const n = t.schema._zod.run({ value: e.value[t.property], issues: [] }, {}); if (n instanceof Promise) return n.then((n => Kt(n, e, t.property))); Kt(n, e, t.property) } })), Xt = t("$ZodCheckMimeType", ((e, t) => { xt.init(e, t); const n = new Set(t.mime); e._zod.onattach.push((e => { e._zod.bag.mime = t.mime })), e._zod.check = i => { n.has(i.value.type) || i.issues.push({ code: "invalid_value", values: t.mime, input: i.value.type, inst: e, continue: !t.abort }) } })), qt = t("$ZodCheckOverwrite", ((e, t) => { xt.init(e, t), e._zod.check = e => { e.value = t.tx(e.value) } })); class Yt { constructor(e = []) { this.content = [], this.indent = 0, this && (this.args = e) } indented(e) { this.indent += 1, e(this), this.indent -= 1 } write(e) { if ("function" == typeof e) return e(this, { execution: "sync" }), void e(this, { execution: "async" }); const t = e.split("\n").filter((e => e)), n = Math.min(...t.map((e => e.length - e.trimStart().length))), i = t.map((e => e.slice(n))).map((e => " ".repeat(2 * this.indent) + e)); for (const e of i) this.content.push(e) } compile() { const e = Function, t = this?.args; return new e(...t, [...(this?.content ?? [""]).map((e => `  ${e}`))].join("\n")) } } const Ht = { major: 4, minor: 1, patch: 12 }, Qt = t("$ZodType", ((e, t) => { var n; e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Ht; const r = [...e._zod.def.checks ?? []]; e._zod.traits.has("$ZodCheck") && r.unshift(e); for (const t of r) for (const n of t._zod.onattach) n(e); if (0 === r.length) (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push((() => { e._zod.run = e._zod.parse })); else { const t = (e, t, n) => { let r, a = R(e); for (const o of t) { if (o._zod.def.when) { if (!o._zod.def.when(e)) continue } else if (a) continue; const t = e.issues.length, s = o._zod.check(e); if (s instanceof Promise && !1 === n?.async) throw new i; if (r || s instanceof Promise) r = (r ?? Promise.resolve()).then((async () => { await s; e.issues.length !== t && (a || (a = R(e, t))) })); else { if (e.issues.length === t) continue; a || (a = R(e, t)) } } return r ? r.then((() => e)) : e }, n = (n, a, o) => { if (R(n)) return n.aborted = !0, n; const s = t(a, r, o); if (s instanceof Promise) { if (!1 === o.async) throw new i; return s.then((t => e._zod.parse(t, o))) } return e._zod.parse(s, o) }; e._zod.run = (a, o) => { if (o.skipChecks) return e._zod.parse(a, o); if ("backward" === o.direction) { const t = e._zod.parse({ value: a.value, issues: [] }, { ...o, skipChecks: !0 }); return t instanceof Promise ? t.then((e => n(e, a, o))) : n(t, a, o) } const s = e._zod.parse(a, o); if (s instanceof Promise) { if (!1 === o.async) throw new i; return s.then((e => t(e, r, o))) } return t(s, r, o) } } e["~standard"] = { validate: t => { try { const n = ce(e, t); return n.success ? { value: n.data } : { issues: n.error?.issues } } catch (n) { return de(e, t).then((e => e.success ? { value: e.data } : { issues: e.error?.issues })) } }, vendor: "zod", version: 1 } })), en = t("$ZodString", ((e, t) => { Qt.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? rt(e._zod.bag), e._zod.parse = (n, i) => { if (t.coerce) try { n.value = String(n.value) } catch (i) { } return "string" == typeof n.value || n.issues.push({ expected: "string", code: "invalid_type", input: n.value, inst: e }), n } })), tn = t("$ZodStringFormat", ((e, t) => { Rt.init(e, t), en.init(e, t) })), nn = t("$ZodGUID", ((e, t) => { t.pattern ?? (t.pattern = Ee), tn.init(e, t) })), rn = t("$ZodUUID", ((e, t) => { if (t.version) { const e = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[t.version]; if (void 0 === e) throw new Error(`Invalid UUID version: "${t.version}"`); t.pattern ?? (t.pattern = Te(e)) } else t.pattern ?? (t.pattern = Te()); tn.init(e, t) })), an = t("$ZodEmail", ((e, t) => { t.pattern ?? (t.pattern = Re), tn.init(e, t) })), on = t("$ZodURL", ((e, t) => { tn.init(e, t), e._zod.check = n => { try { const i = n.value.trim(), r = new URL(i); return t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(r.hostname) || n.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: qe.source, input: n.value, inst: e, continue: !t.abort })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(r.protocol.endsWith(":") ? r.protocol.slice(0, -1) : r.protocol) || n.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: t.protocol.source, input: n.value, inst: e, continue: !t.abort })), void (t.normalize ? n.value = r.href : n.value = i) } catch (i) { n.issues.push({ code: "invalid_format", format: "url", input: n.value, inst: e, continue: !t.abort }) } } })), sn = t("$ZodEmoji", ((e, t) => { t.pattern ?? (t.pattern = Me()), tn.init(e, t) })), un = t("$ZodNanoID", ((e, t) => { t.pattern ?? (t.pattern = Ze), tn.init(e, t) })), cn = t("$ZodCUID", ((e, t) => { t.pattern ?? (t.pattern = Oe), tn.init(e, t) })), ln = t("$ZodCUID2", ((e, t) => { t.pattern ?? (t.pattern = Ue), tn.init(e, t) })), dn = t("$ZodULID", ((e, t) => { t.pattern ?? (t.pattern = je), tn.init(e, t) })), mn = t("$ZodXID", ((e, t) => { t.pattern ?? (t.pattern = Ne), tn.init(e, t) })), pn = t("$ZodKSUID", ((e, t) => { t.pattern ?? (t.pattern = De), tn.init(e, t) })), fn = t("$ZodISODateTime", ((e, t) => { t.pattern ?? (t.pattern = it(t)), tn.init(e, t) })), vn = t("$ZodISODate", ((e, t) => { t.pattern ?? (t.pattern = et), tn.init(e, t) })), gn = t("$ZodISOTime", ((e, t) => { t.pattern ?? (t.pattern = nt(t)), tn.init(e, t) })), hn = t("$ZodISODuration", ((e, t) => { t.pattern ?? (t.pattern = Pe), tn.init(e, t) })), $n = t("$ZodIPv4", ((e, t) => { t.pattern ?? (t.pattern = We), tn.init(e, t), e._zod.onattach.push((e => { e._zod.bag.format = "ipv4" })) })), yn = t("$ZodIPv6", ((e, t) => { t.pattern ?? (t.pattern = Ge), tn.init(e, t), e._zod.onattach.push((e => { e._zod.bag.format = "ipv6" })), e._zod.check = n => { try { new URL(`http://[${n.value}]`) } catch { n.issues.push({ code: "invalid_format", format: "ipv6", input: n.value, inst: e, continue: !t.abort }) } } })), _n = t("$ZodCIDRv4", ((e, t) => { t.pattern ?? (t.pattern = Ve), tn.init(e, t) })), bn = t("$ZodCIDRv6", ((e, t) => { t.pattern ?? (t.pattern = Ke), tn.init(e, t), e._zod.check = n => { const i = n.value.split("/"); try { if (2 !== i.length) throw new Error; const [e, t] = i; if (!t) throw new Error; const n = Number(t); if (`${n}` !== t) throw new Error; if (n < 0 || n > 128) throw new Error; new URL(`http://[${e}]`) } catch { n.issues.push({ code: "invalid_format", format: "cidrv6", input: n.value, inst: e, continue: !t.abort }) } } })); function kn(e) { if ("" === e) return !0; if (e.length % 4 != 0) return !1; try { return atob(e), !0 } catch { return !1 } } const In = t("$ZodBase64", ((e, t) => { t.pattern ?? (t.pattern = Be), tn.init(e, t), e._zod.onattach.push((e => { e._zod.bag.contentEncoding = "base64" })), e._zod.check = n => { kn(n.value) || n.issues.push({ code: "invalid_format", format: "base64", input: n.value, inst: e, continue: !t.abort }) } })); function wn(e) { if (!Xe.test(e)) return !1; const t = e.replace(/[-_]/g, (e => "-" === e ? "+" : "/")); return kn(t.padEnd(4 * Math.ceil(t.length / 4), "=")) } const zn = t("$ZodBase64URL", ((e, t) => { t.pattern ?? (t.pattern = Xe), tn.init(e, t), e._zod.onattach.push((e => { e._zod.bag.contentEncoding = "base64url" })), e._zod.check = n => { wn(n.value) || n.issues.push({ code: "invalid_format", format: "base64url", input: n.value, inst: e, continue: !t.abort }) } })), Sn = t("$ZodE164", ((e, t) => { t.pattern ?? (t.pattern = He), tn.init(e, t) })); function xn(e, t = null) { try { const n = e.split("."); if (3 !== n.length) return !1; const [i] = n; if (!i) return !1; const r = JSON.parse(atob(i)); return (!("typ" in r) || "JWT" === r?.typ) && (!!r.alg && (!t || "alg" in r && r.alg === t)) } catch { return !1 } } const On = t("$ZodJWT", ((e, t) => { tn.init(e, t), e._zod.check = n => { xn(n.value, t.alg) || n.issues.push({ code: "invalid_format", format: "jwt", input: n.value, inst: e, continue: !t.abort }) } })), Un = t("$ZodCustomStringFormat", ((e, t) => { tn.init(e, t), e._zod.check = n => { t.fn(n.value) || n.issues.push({ code: "invalid_format", format: t.format, input: n.value, inst: e, continue: !t.abort }) } })), jn = t("$ZodNumber", ((e, t) => { Qt.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? st, e._zod.parse = (n, i) => { if (t.coerce) try { n.value = Number(n.value) } catch (e) { } const r = n.value; if ("number" == typeof r && !Number.isNaN(r) && Number.isFinite(r)) return n; const a = "number" == typeof r ? Number.isNaN(r) ? "NaN" : Number.isFinite(r) ? void 0 : "Infinity" : void 0; return n.issues.push({ expected: "number", code: "invalid_type", input: r, inst: e, ...a ? { received: a } : {} }), n } })), Nn = t("$ZodNumber", ((e, t) => { Dt.init(e, t), jn.init(e, t) })), Dn = t("$ZodBoolean", ((e, t) => { Qt.init(e, t), e._zod.pattern = ut, e._zod.parse = (n, i) => { if (t.coerce) try { n.value = Boolean(n.value) } catch (e) { } const r = n.value; return "boolean" == typeof r || n.issues.push({ expected: "boolean", code: "invalid_type", input: r, inst: e }), n } })), Zn = t("$ZodBigInt", ((e, t) => { Qt.init(e, t), e._zod.pattern = at, e._zod.parse = (n, i) => { if (t.coerce) try { n.value = BigInt(n.value) } catch (e) { } return "bigint" == typeof n.value || n.issues.push({ expected: "bigint", code: "invalid_type", input: n.value, inst: e }), n } })), Pn = t("$ZodBigInt", ((e, t) => { Zt.init(e, t), Zn.init(e, t) })), En = t("$ZodSymbol", ((e, t) => { Qt.init(e, t), e._zod.parse = (t, n) => { const i = t.value; return "symbol" == typeof i || t.issues.push({ expected: "symbol", code: "invalid_type", input: i, inst: e }), t } })), Tn = t("$ZodUndefined", ((e, t) => { Qt.init(e, t), e._zod.pattern = lt, e._zod.values = new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (t, n) => { const i = t.value; return void 0 === i || t.issues.push({ expected: "undefined", code: "invalid_type", input: i, inst: e }), t } })), An = t("$ZodNull", ((e, t) => { Qt.init(e, t), e._zod.pattern = ct, e._zod.values = new Set([null]), e._zod.parse = (t, n) => { const i = t.value; return null === i || t.issues.push({ expected: "null", code: "invalid_type", input: i, inst: e }), t } })), Ln = t("$ZodAny", ((e, t) => { Qt.init(e, t), e._zod.parse = e => e })), Cn = t("$ZodUnknown", ((e, t) => { Qt.init(e, t), e._zod.parse = e => e })), Rn = t("$ZodNever", ((e, t) => { Qt.init(e, t), e._zod.parse = (t, n) => (t.issues.push({ expected: "never", code: "invalid_type", input: t.value, inst: e }), t) })), Fn = t("$ZodVoid", ((e, t) => { Qt.init(e, t), e._zod.parse = (t, n) => { const i = t.value; return void 0 === i || t.issues.push({ expected: "void", code: "invalid_type", input: i, inst: e }), t } })), Jn = t("$ZodDate", ((e, t) => { Qt.init(e, t), e._zod.parse = (n, i) => { if (t.coerce) try { n.value = new Date(n.value) } catch (e) { } const r = n.value, a = r instanceof Date; return a && !Number.isNaN(r.getTime()) || n.issues.push({ expected: "date", code: "invalid_type", input: r, ...a ? { received: "Invalid Date" } : {}, inst: e }), n } })); function Mn(e, t, n) { e.issues.length && t.issues.push(...F(n, e.issues)), t.value[n] = e.value } const Wn = t("$ZodArray", ((e, t) => { Qt.init(e, t), e._zod.parse = (n, i) => { const r = n.value; if (!Array.isArray(r)) return n.issues.push({ expected: "array", code: "invalid_type", input: r, inst: e }), n; n.value = Array(r.length); const a = []; for (let e = 0; e < r.length; e++) { const o = r[e], s = t.element._zod.run({ value: o, issues: [] }, i); s instanceof Promise ? a.push(s.then((t => Mn(t, n, e)))) : Mn(s, n, e) } return a.length ? Promise.all(a).then((() => n)) : n } })); function Gn(e, t, n, i) { e.issues.length && t.issues.push(...F(n, e.issues)), void 0 === e.value ? n in i && (t.value[n] = void 0) : t.value[n] = e.value } function Vn(e) { const t = Object.keys(e.shape); for (const n of t) if (!e.shape?.[n]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${n}": expected a Zod schema`); const n = j(e.shape); return { ...e, keys: t, keySet: new Set(t), numKeys: t.length, optionalKeys: new Set(n) } } function Kn(e, t, n, i, r, a) { const o = [], s = r.keySet, u = r.catchall._zod, c = u.def.type; for (const r of Object.keys(t)) { if (s.has(r)) continue; if ("never" === c) { o.push(r); continue } const a = u.run({ value: t[r], issues: [] }, i); a instanceof Promise ? e.push(a.then((e => Gn(e, n, r, t)))) : Gn(a, n, r, t) } return o.length && n.issues.push({ code: "unrecognized_keys", keys: o, input: t, inst: a }), e.length ? Promise.all(e).then((() => n)) : n } const Bn = t("$ZodObject", ((e, t) => { Qt.init(e, t); const n = Object.getOwnPropertyDescriptor(t, "shape"); if (!n?.get) { const e = t.shape; Object.defineProperty(t, "shape", { get: () => { const n = { ...e }; return Object.defineProperty(t, "shape", { value: n }), n } }) } const i = l((() => Vn(t))); v(e._zod, "propValues", (() => { const e = t.shape, n = {}; for (const t in e) { const i = e[t]._zod; if (i.values) { n[t] ?? (n[t] = new Set); for (const e of i.values) n[t].add(e) } } return n })); const r = _, a = t.catchall; let o; e._zod.parse = (t, n) => { o ?? (o = i.value); const s = t.value; if (!r(s)) return t.issues.push({ expected: "object", code: "invalid_type", input: s, inst: e }), t; t.value = {}; const u = [], c = o.shape; for (const e of o.keys) { const i = c[e]._zod.run({ value: s[e], issues: [] }, n); i instanceof Promise ? u.push(i.then((n => Gn(n, t, e, s)))) : Gn(i, t, e, s) } return a ? Kn(u, s, t, n, i.value, e) : u.length ? Promise.all(u).then((() => t)) : t } })), Xn = t("$ZodObjectJIT", ((e, t) => { Bn.init(e, t); const n = e._zod.parse, i = l((() => Vn(t))); let r; const o = _, s = !a.jitless, u = s && b.value, c = t.catchall; let d; e._zod.parse = (a, l) => { d ?? (d = i.value); const m = a.value; return o(m) ? s && u && !1 === l?.async && !0 !== l.jitless ? (r || (r = (e => { const t = new Yt(["shape", "payload", "ctx"]), n = i.value, r = e => { const t = $(e); return `shape[${t}]._zod.run({ value: input[${t}], issues: [] }, ctx)` }; t.write("const input = payload.value;"); const a = Object.create(null); let o = 0; for (const e of n.keys) a[e] = "key_" + o++; t.write("const newResult = {};"); for (const e of n.keys) { const n = a[e], i = $(e); t.write(`const ${n} = ${r(e)};`), t.write(`\n        if (${n}.issues.length) {\n          payload.issues = payload.issues.concat(${n}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${i}, ...iss.path] : [${i}]\n          })));\n        }\n        \n        \n        if (${n}.value === undefined) {\n          if (${i} in input) {\n            newResult[${i}] = undefined;\n          }\n        } else {\n          newResult[${i}] = ${n}.value;\n        }\n        \n      `) } t.write("payload.value = newResult;"), t.write("return payload;"); const s = t.compile(); return (t, n) => s(e, t, n) })(t.shape)), a = r(a, l), c ? Kn([], m, a, l, d, e) : a) : n(a, l) : (a.issues.push({ expected: "object", code: "invalid_type", input: m, inst: e }), a) } })); function qn(e, t, n, i) { for (const n of e) if (0 === n.issues.length) return t.value = n.value, t; const r = e.filter((e => !R(e))); return 1 === r.length ? (t.value = r[0].value, r[0]) : (t.issues.push({ code: "invalid_union", input: t.value, inst: n, errors: e.map((e => e.issues.map((e => M(e, i, o()))))) }), t) } const Yn = t("$ZodUnion", ((e, t) => { Qt.init(e, t), v(e._zod, "optin", (() => t.options.some((e => "optional" === e._zod.optin)) ? "optional" : void 0)), v(e._zod, "optout", (() => t.options.some((e => "optional" === e._zod.optout)) ? "optional" : void 0)), v(e._zod, "values", (() => { if (t.options.every((e => e._zod.values))) return new Set(t.options.flatMap((e => Array.from(e._zod.values)))) })), v(e._zod, "pattern", (() => { if (t.options.every((e => e._zod.pattern))) { const e = t.options.map((e => e._zod.pattern)); return new RegExp(`^(${e.map((e => m(e.source))).join("|")})$`) } })); const n = 1 === t.options.length, i = t.options[0]._zod.run; e._zod.parse = (r, a) => { if (n) return i(r, a); let o = !1; const s = []; for (const e of t.options) { const t = e._zod.run({ value: r.value, issues: [] }, a); if (t instanceof Promise) s.push(t), o = !0; else { if (0 === t.issues.length) return t; s.push(t) } } return o ? Promise.all(s).then((t => qn(t, r, e, a))) : qn(s, r, e, a) } })), Hn = t("$ZodDiscriminatedUnion", ((e, t) => { Yn.init(e, t); const n = e._zod.parse; v(e._zod, "propValues", (() => { const e = {}; for (const n of t.options) { const i = n._zod.propValues; if (!i || 0 === Object.keys(i).length) throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(n)}"`); for (const [t, n] of Object.entries(i)) { e[t] || (e[t] = new Set); for (const i of n) e[t].add(i) } } return e })); const i = l((() => { const e = t.options, n = new Map; for (const i of e) { const e = i._zod.propValues?.[t.discriminator]; if (!e || 0 === e.size) throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(i)}"`); for (const t of e) { if (n.has(t)) throw new Error(`Duplicate discriminator value "${String(t)}"`); n.set(t, i) } } return n })); e._zod.parse = (r, a) => { const o = r.value; if (!_(o)) return r.issues.push({ code: "invalid_type", expected: "object", input: o, inst: e }), r; const s = i.value.get(o?.[t.discriminator]); return s ? s._zod.run(r, a) : t.unionFallback ? n(r, a) : (r.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: t.discriminator, input: o, path: [t.discriminator], inst: e }), r) } })), Qn = t("$ZodIntersection", ((e, t) => { Qt.init(e, t), e._zod.parse = (e, n) => { const i = e.value, r = t.left._zod.run({ value: i, issues: [] }, n), a = t.right._zod.run({ value: i, issues: [] }, n); return r instanceof Promise || a instanceof Promise ? Promise.all([r, a]).then((([t, n]) => ti(e, t, n))) : ti(e, r, a) } })); function ei(e, t) { if (e === t) return { valid: !0, data: e }; if (e instanceof Date && t instanceof Date && +e == +t) return { valid: !0, data: e }; if (k(e) && k(t)) { const n = Object.keys(t), i = Object.keys(e).filter((e => -1 !== n.indexOf(e))), r = { ...e, ...t }; for (const n of i) { const i = ei(e[n], t[n]); if (!i.valid) return { valid: !1, mergeErrorPath: [n, ...i.mergeErrorPath] }; r[n] = i.data } return { valid: !0, data: r } } if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return { valid: !1, mergeErrorPath: [] }; const n = []; for (let i = 0; i < e.length; i++) { const r = ei(e[i], t[i]); if (!r.valid) return { valid: !1, mergeErrorPath: [i, ...r.mergeErrorPath] }; n.push(r.data) } return { valid: !0, data: n } } return { valid: !1, mergeErrorPath: [] } } function ti(e, t, n) { if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), R(e)) return e; const i = ei(t.value, n.value); if (!i.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`); return e.value = i.data, e } const ni = t("$ZodTuple", ((e, t) => { Qt.init(e, t); const n = t.items, i = n.length - [...n].reverse().findIndex((e => "optional" !== e._zod.optin)); e._zod.parse = (r, a) => { const o = r.value; if (!Array.isArray(o)) return r.issues.push({ input: o, inst: e, expected: "tuple", code: "invalid_type" }), r; r.value = []; const s = []; if (!t.rest) { const t = o.length > n.length, a = o.length < i - 1; if (t || a) return r.issues.push({ ...t ? { code: "too_big", maximum: n.length } : { code: "too_small", minimum: n.length }, input: o, inst: e, origin: "array" }), r } let u = -1; for (const e of n) { if (u++, u >= o.length && u >= i) continue; const t = e._zod.run({ value: o[u], issues: [] }, a); t instanceof Promise ? s.push(t.then((e => ii(e, r, u)))) : ii(t, r, u) } if (t.rest) { const e = o.slice(n.length); for (const n of e) { u++; const e = t.rest._zod.run({ value: n, issues: [] }, a); e instanceof Promise ? s.push(e.then((e => ii(e, r, u)))) : ii(e, r, u) } } return s.length ? Promise.all(s).then((() => r)) : r } })); function ii(e, t, n) { e.issues.length && t.issues.push(...F(n, e.issues)), t.value[n] = e.value } const ri = t("$ZodRecord", ((e, t) => { Qt.init(e, t), e._zod.parse = (n, i) => { const r = n.value; if (!k(r)) return n.issues.push({ expected: "record", code: "invalid_type", input: r, inst: e }), n; const a = []; if (t.keyType._zod.values) { const o = t.keyType._zod.values; n.value = {}; for (const e of o) if ("string" == typeof e || "number" == typeof e || "symbol" == typeof e) { const o = t.valueType._zod.run({ value: r[e], issues: [] }, i); o instanceof Promise ? a.push(o.then((t => { t.issues.length && n.issues.push(...F(e, t.issues)), n.value[e] = t.value }))) : (o.issues.length && n.issues.push(...F(e, o.issues)), n.value[e] = o.value) } let s; for (const e in r) o.has(e) || (s = s ?? [], s.push(e)); s && s.length > 0 && n.issues.push({ code: "unrecognized_keys", input: r, inst: e, keys: s }) } else { n.value = {}; for (const s of Reflect.ownKeys(r)) { if ("__proto__" === s) continue; const u = t.keyType._zod.run({ value: s, issues: [] }, i); if (u instanceof Promise) throw new Error("Async schemas not supported in object keys currently"); if (u.issues.length) { n.issues.push({ code: "invalid_key", origin: "record", issues: u.issues.map((e => M(e, i, o()))), input: s, path: [s], inst: e }), n.value[u.value] = u.value; continue } const c = t.valueType._zod.run({ value: r[s], issues: [] }, i); c instanceof Promise ? a.push(c.then((e => { e.issues.length && n.issues.push(...F(s, e.issues)), n.value[u.value] = e.value }))) : (c.issues.length && n.issues.push(...F(s, c.issues)), n.value[u.value] = c.value) } } return a.length ? Promise.all(a).then((() => n)) : n } })), ai = t("$ZodMap", ((e, t) => { Qt.init(e, t), e._zod.parse = (n, i) => { const r = n.value; if (!(r instanceof Map)) return n.issues.push({ expected: "map", code: "invalid_type", input: r, inst: e }), n; const a = []; n.value = new Map; for (const [o, s] of r) { const u = t.keyType._zod.run({ value: o, issues: [] }, i), c = t.valueType._zod.run({ value: s, issues: [] }, i); u instanceof Promise || c instanceof Promise ? a.push(Promise.all([u, c]).then((([t, a]) => { oi(t, a, n, o, r, e, i) }))) : oi(u, c, n, o, r, e, i) } return a.length ? Promise.all(a).then((() => n)) : n } })); function oi(e, t, n, i, r, a, s) { e.issues.length && (w.has(typeof i) ? n.issues.push(...F(i, e.issues)) : n.issues.push({ code: "invalid_key", origin: "map", input: r, inst: a, issues: e.issues.map((e => M(e, s, o()))) })), t.issues.length && (w.has(typeof i) ? n.issues.push(...F(i, t.issues)) : n.issues.push({ origin: "map", code: "invalid_element", input: r, inst: a, key: i, issues: t.issues.map((e => M(e, s, o()))) })), n.value.set(e.value, t.value) } const si = t("$ZodSet", ((e, t) => { Qt.init(e, t), e._zod.parse = (n, i) => { const r = n.value; if (!(r instanceof Set)) return n.issues.push({ input: r, inst: e, expected: "set", code: "invalid_type" }), n; const a = []; n.value = new Set; for (const e of r) { const r = t.valueType._zod.run({ value: e, issues: [] }, i); r instanceof Promise ? a.push(r.then((e => ui(e, n)))) : ui(r, n) } return a.length ? Promise.all(a).then((() => n)) : n } })); function ui(e, t) { e.issues.length && t.issues.push(...e.issues), t.value.add(e.value) } const ci = t("$ZodEnum", ((e, t) => { Qt.init(e, t); const n = s(t.entries), i = new Set(n); e._zod.values = i, e._zod.pattern = new RegExp(`^(${n.filter((e => w.has(typeof e))).map((e => "string" == typeof e ? S(e) : e.toString())).join("|")})$`), e._zod.parse = (t, r) => { const a = t.value; return i.has(a) || t.issues.push({ code: "invalid_value", values: n, input: a, inst: e }), t } })), li = t("$ZodLiteral", ((e, t) => { if (Qt.init(e, t), 0 === t.values.length) throw new Error("Cannot create literal schema with no valid values"); e._zod.values = new Set(t.values), e._zod.pattern = new RegExp(`^(${t.values.map((e => "string" == typeof e ? S(e) : e ? S(e.toString()) : String(e))).join("|")})$`), e._zod.parse = (n, i) => { const r = n.value; return e._zod.values.has(r) || n.issues.push({ code: "invalid_value", values: t.values, input: r, inst: e }), n } })), di = t("$ZodFile", ((e, t) => { Qt.init(e, t), e._zod.parse = (t, n) => { const i = t.value; return i instanceof File || t.issues.push({ expected: "file", code: "invalid_type", input: i, inst: e }), t } })), mi = t("$ZodTransform", ((e, t) => { Qt.init(e, t), e._zod.parse = (n, a) => { if ("backward" === a.direction) throw new r(e.constructor.name); const o = t.transform(n.value, n); if (a.async) { return (o instanceof Promise ? o : Promise.resolve(o)).then((e => (n.value = e, n))) } if (o instanceof Promise) throw new i; return n.value = o, n } })); function pi(e, t) { return e.issues.length && void 0 === t ? { issues: [], value: void 0 } : e } const fi = t("$ZodOptional", ((e, t) => { Qt.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", v(e._zod, "values", (() => t.innerType._zod.values ? new Set([...t.innerType._zod.values, void 0]) : void 0)), v(e._zod, "pattern", (() => { const e = t.innerType._zod.pattern; return e ? new RegExp(`^(${m(e.source)})?$`) : void 0 })), e._zod.parse = (e, n) => { if ("optional" === t.innerType._zod.optin) { const i = t.innerType._zod.run(e, n); return i instanceof Promise ? i.then((t => pi(t, e.value))) : pi(i, e.value) } return void 0 === e.value ? e : t.innerType._zod.run(e, n) } })), vi = t("$ZodNullable", ((e, t) => { Qt.init(e, t), v(e._zod, "optin", (() => t.innerType._zod.optin)), v(e._zod, "optout", (() => t.innerType._zod.optout)), v(e._zod, "pattern", (() => { const e = t.innerType._zod.pattern; return e ? new RegExp(`^(${m(e.source)}|null)$`) : void 0 })), v(e._zod, "values", (() => t.innerType._zod.values ? new Set([...t.innerType._zod.values, null]) : void 0)), e._zod.parse = (e, n) => null === e.value ? e : t.innerType._zod.run(e, n) })), gi = t("$ZodDefault", ((e, t) => { Qt.init(e, t), e._zod.optin = "optional", v(e._zod, "values", (() => t.innerType._zod.values)), e._zod.parse = (e, n) => { if ("backward" === n.direction) return t.innerType._zod.run(e, n); if (void 0 === e.value) return e.value = t.defaultValue, e; const i = t.innerType._zod.run(e, n); return i instanceof Promise ? i.then((e => hi(e, t))) : hi(i, t) } })); function hi(e, t) { return void 0 === e.value && (e.value = t.defaultValue), e } const $i = t("$ZodPrefault", ((e, t) => { Qt.init(e, t), e._zod.optin = "optional", v(e._zod, "values", (() => t.innerType._zod.values)), e._zod.parse = (e, n) => ("backward" === n.direction || void 0 === e.value && (e.value = t.defaultValue), t.innerType._zod.run(e, n)) })), yi = t("$ZodNonOptional", ((e, t) => { Qt.init(e, t), v(e._zod, "values", (() => { const e = t.innerType._zod.values; return e ? new Set([...e].filter((e => void 0 !== e))) : void 0 })), e._zod.parse = (n, i) => { const r = t.innerType._zod.run(n, i); return r instanceof Promise ? r.then((t => _i(t, e))) : _i(r, e) } })); function _i(e, t) { return e.issues.length || void 0 !== e.value || e.issues.push({ code: "invalid_type", expected: "nonoptional", input: e.value, inst: t }), e } const bi = t("$ZodSuccess", ((e, t) => { Qt.init(e, t), e._zod.parse = (e, n) => { if ("backward" === n.direction) throw new r("ZodSuccess"); const i = t.innerType._zod.run(e, n); return i instanceof Promise ? i.then((t => (e.value = 0 === t.issues.length, e))) : (e.value = 0 === i.issues.length, e) } })), ki = t("$ZodCatch", ((e, t) => { Qt.init(e, t), v(e._zod, "optin", (() => t.innerType._zod.optin)), v(e._zod, "optout", (() => t.innerType._zod.optout)), v(e._zod, "values", (() => t.innerType._zod.values)), e._zod.parse = (e, n) => { if ("backward" === n.direction) return t.innerType._zod.run(e, n); const i = t.innerType._zod.run(e, n); return i instanceof Promise ? i.then((i => (e.value = i.value, i.issues.length && (e.value = t.catchValue({ ...e, error: { issues: i.issues.map((e => M(e, n, o()))) }, input: e.value }), e.issues = []), e))) : (e.value = i.value, i.issues.length && (e.value = t.catchValue({ ...e, error: { issues: i.issues.map((e => M(e, n, o()))) }, input: e.value }), e.issues = []), e) } })), Ii = t("$ZodNaN", ((e, t) => { Qt.init(e, t), e._zod.parse = (t, n) => ("number" == typeof t.value && Number.isNaN(t.value) || t.issues.push({ input: t.value, inst: e, expected: "nan", code: "invalid_type" }), t) })), wi = t("$ZodPipe", ((e, t) => { Qt.init(e, t), v(e._zod, "values", (() => t.in._zod.values)), v(e._zod, "optin", (() => t.in._zod.optin)), v(e._zod, "optout", (() => t.out._zod.optout)), v(e._zod, "propValues", (() => t.in._zod.propValues)), e._zod.parse = (e, n) => { if ("backward" === n.direction) { const i = t.out._zod.run(e, n); return i instanceof Promise ? i.then((e => zi(e, t.in, n))) : zi(i, t.in, n) } const i = t.in._zod.run(e, n); return i instanceof Promise ? i.then((e => zi(e, t.out, n))) : zi(i, t.out, n) } })); function zi(e, t, n) { return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n) } const Si = t("$ZodCodec", ((e, t) => { Qt.init(e, t), v(e._zod, "values", (() => t.in._zod.values)), v(e._zod, "optin", (() => t.in._zod.optin)), v(e._zod, "optout", (() => t.out._zod.optout)), v(e._zod, "propValues", (() => t.in._zod.propValues)), e._zod.parse = (e, n) => { if ("forward" === (n.direction || "forward")) { const i = t.in._zod.run(e, n); return i instanceof Promise ? i.then((e => xi(e, t, n))) : xi(i, t, n) } { const i = t.out._zod.run(e, n); return i instanceof Promise ? i.then((e => xi(e, t, n))) : xi(i, t, n) } } })); function xi(e, t, n) { if (e.issues.length) return e.aborted = !0, e; if ("forward" === (n.direction || "forward")) { const i = t.transform(e.value, e); return i instanceof Promise ? i.then((i => Oi(e, i, t.out, n))) : Oi(e, i, t.out, n) } { const i = t.reverseTransform(e.value, e); return i instanceof Promise ? i.then((i => Oi(e, i, t.in, n))) : Oi(e, i, t.in, n) } } function Oi(e, t, n, i) { return e.issues.length ? (e.aborted = !0, e) : n._zod.run({ value: t, issues: e.issues }, i) } const Ui = t("$ZodReadonly", ((e, t) => { Qt.init(e, t), v(e._zod, "propValues", (() => t.innerType._zod.propValues)), v(e._zod, "values", (() => t.innerType._zod.values)), v(e._zod, "optin", (() => t.innerType._zod.optin)), v(e._zod, "optout", (() => t.innerType._zod.optout)), e._zod.parse = (e, n) => { if ("backward" === n.direction) return t.innerType._zod.run(e, n); const i = t.innerType._zod.run(e, n); return i instanceof Promise ? i.then(ji) : ji(i) } })); function ji(e) { return e.value = Object.freeze(e.value), e } const Ni = t("$ZodTemplateLiteral", ((e, t) => { Qt.init(e, t); const n = []; for (const e of t.parts) if ("object" == typeof e && null !== e) { if (!e._zod.pattern) throw new Error(`Invalid template literal part, no pattern found: ${[...e._zod.traits].shift()}`); const t = e._zod.pattern instanceof RegExp ? e._zod.pattern.source : e._zod.pattern; if (!t) throw new Error(`Invalid template literal part: ${e._zod.traits}`); const i = t.startsWith("^") ? 1 : 0, r = t.endsWith("$") ? t.length - 1 : t.length; n.push(t.slice(i, r)) } else { if (null !== e && !z.has(typeof e)) throw new Error(`Invalid template literal part: ${e}`); n.push(S(`${e}`)) } e._zod.pattern = new RegExp(`^${n.join("")}$`), e._zod.parse = (n, i) => "string" != typeof n.value ? (n.issues.push({ input: n.value, inst: e, expected: "template_literal", code: "invalid_type" }), n) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(n.value) || n.issues.push({ input: n.value, inst: e, code: "invalid_format", format: t.format ?? "template_literal", pattern: e._zod.pattern.source }), n) })), Di = t("$ZodFunction", ((e, t) => (Qt.init(e, t), e._def = t, e._zod.def = t, e.implement = t => { if ("function" != typeof t) throw new Error("implement() must be called with a function"); return function (...n) { const i = e._def.input ? ae(e._def.input, n) : n, r = Reflect.apply(t, this, i); return e._def.output ? ae(e._def.output, r) : r } }, e.implementAsync = t => { if ("function" != typeof t) throw new Error("implementAsync() must be called with a function"); return async function (...n) { const i = e._def.input ? await se(e._def.input, n) : n, r = await Reflect.apply(t, this, i); return e._def.output ? await se(e._def.output, r) : r } }, e._zod.parse = (t, n) => { if ("function" != typeof t.value) return t.issues.push({ code: "invalid_type", expected: "function", input: t.value, inst: e }), t; const i = e._def.output && "promise" === e._def.output._zod.def.type; return t.value = i ? e.implementAsync(t.value) : e.implement(t.value), t }, e.input = (...t) => { const n = e.constructor; return Array.isArray(t[0]) ? new n({ type: "function", input: new ni({ type: "tuple", items: t[0], rest: t[1] }), output: e._def.output }) : new n({ type: "function", input: t[0], output: e._def.output }) }, e.output = t => new (0, e.constructor)({ type: "function", input: e._def.input, output: t }), e))), Zi = t("$ZodPromise", ((e, t) => { Qt.init(e, t), e._zod.parse = (e, n) => Promise.resolve(e.value).then((e => t.innerType._zod.run({ value: e, issues: [] }, n))) })), Pi = t("$ZodLazy", ((e, t) => { Qt.init(e, t), v(e._zod, "innerType", (() => t.getter())), v(e._zod, "pattern", (() => e._zod.innerType._zod.pattern)), v(e._zod, "propValues", (() => e._zod.innerType._zod.propValues)), v(e._zod, "optin", (() => e._zod.innerType._zod.optin ?? void 0)), v(e._zod, "optout", (() => e._zod.innerType._zod.optout ?? void 0)), e._zod.parse = (t, n) => e._zod.innerType._zod.run(t, n) })), Ei = t("$ZodCustom", ((e, t) => { xt.init(e, t), Qt.init(e, t), e._zod.parse = (e, t) => e, e._zod.check = n => { const i = n.value, r = t.fn(i); if (r instanceof Promise) return r.then((t => Ti(t, n, i, e))); Ti(r, n, i, e) } })); function Ti(e, t, n, i) { if (!e) { const e = { code: "custom", input: n, inst: i, path: [...i._zod.def.path ?? []], continue: !i._zod.def.abort }; i._zod.def.params && (e.params = i._zod.def.params), t.issues.push(V(e)) } } const Ai = () => { const e = { string: { unit: "حرف", verb: "أن يحوي" }, file: { unit: "بايت", verb: "أن يحوي" }, array: { unit: "عنصر", verb: "أن يحوي" }, set: { unit: "عنصر", verb: "أن يحوي" } }; function t(t) { return e[t] ?? null } const n = { regex: "مدخل", email: "بريد إلكتروني", url: "رابط", emoji: "إيموجي", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "تاريخ ووقت بمعيار ISO", date: "تاريخ بمعيار ISO", time: "وقت بمعيار ISO", duration: "مدة بمعيار ISO", ipv4: "عنوان IPv4", ipv6: "عنوان IPv6", cidrv4: "مدى عناوين بصيغة IPv4", cidrv6: "مدى عناوين بصيغة IPv6", base64: "نَص بترميز base64-encoded", base64url: "نَص بترميز base64url-encoded", json_string: "نَص على هيئة JSON", e164: "رقم هاتف بمعيار E.164", jwt: "JWT", template_literal: "مدخل" }; return e => { switch (e.code) { case "invalid_type": return `مدخلات غير مقبولة: يفترض إدخال ${e.expected}، ولكن تم إدخال ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `مدخلات غير مقبولة: يفترض إدخال ${U(e.values[0])}` : `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? ` أكبر من اللازم: يفترض أن تكون ${e.origin ?? "القيمة"} ${n} ${e.maximum.toString()} ${i.unit ?? "عنصر"}` : `أكبر من اللازم: يفترض أن تكون ${e.origin ?? "القيمة"} ${n} ${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `أصغر من اللازم: يفترض لـ ${e.origin} أن يكون ${n} ${e.minimum.toString()} ${i.unit}` : `أصغر من اللازم: يفترض لـ ${e.origin} أن يكون ${n} ${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `نَص غير مقبول: يجب أن يبدأ بـ "${e.prefix}"` : "ends_with" === t.format ? `نَص غير مقبول: يجب أن ينتهي بـ "${t.suffix}"` : "includes" === t.format ? `نَص غير مقبول: يجب أن يتضمَّن "${t.includes}"` : "regex" === t.format ? `نَص غير مقبول: يجب أن يطابق النمط ${t.pattern}` : `${n[t.format] ?? e.format} غير مقبول` } case "not_multiple_of": return `رقم غير مقبول: يجب أن يكون من مضاعفات ${e.divisor}`; case "unrecognized_keys": return `معرف${e.keys.length > 1 ? "ات" : ""} غريب${e.keys.length > 1 ? "ة" : ""}: ${u(e.keys, "، ")}`; case "invalid_key": return `معرف غير مقبول في ${e.origin}`; case "invalid_union": default: return "مدخل غير مقبول"; case "invalid_element": return `مدخل غير مقبول في ${e.origin}` } } }; const Li = () => { const e = { string: { unit: "simvol", verb: "olmalıdır" }, file: { unit: "bayt", verb: "olmalıdır" }, array: { unit: "element", verb: "olmalıdır" }, set: { unit: "element", verb: "olmalıdır" } }; function t(t) { return e[t] ?? null } const n = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Yanlış dəyər: gözlənilən ${e.expected}, daxil olan ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Yanlış dəyər: gözlənilən ${U(e.values[0])}` : `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Çox böyük: gözlənilən ${e.origin ?? "dəyər"} ${n}${e.maximum.toString()} ${i.unit ?? "element"}` : `Çox böyük: gözlənilən ${e.origin ?? "dəyər"} ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Çox kiçik: gözlənilən ${e.origin} ${n}${e.minimum.toString()} ${i.unit}` : `Çox kiçik: gözlənilən ${e.origin} ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Yanlış mətn: "${t.prefix}" ilə başlamalıdır` : "ends_with" === t.format ? `Yanlış mətn: "${t.suffix}" ilə bitməlidir` : "includes" === t.format ? `Yanlış mətn: "${t.includes}" daxil olmalıdır` : "regex" === t.format ? `Yanlış mətn: ${t.pattern} şablonuna uyğun olmalıdır` : `Yanlış ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Yanlış ədəd: ${e.divisor} ilə bölünə bilən olmalıdır`; case "unrecognized_keys": return `Tanınmayan açar${e.keys.length > 1 ? "lar" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `${e.origin} daxilində yanlış açar`; case "invalid_union": default: return "Yanlış dəyər"; case "invalid_element": return `${e.origin} daxilində yanlış dəyər` } } }; function Ci(e, t, n, i) { const r = Math.abs(e), a = r % 10, o = r % 100; return o >= 11 && o <= 19 ? i : 1 === a ? t : a >= 2 && a <= 4 ? n : i } const Ri = () => { const e = { string: { unit: { one: "сімвал", few: "сімвалы", many: "сімвалаў" }, verb: "мець" }, array: { unit: { one: "элемент", few: "элементы", many: "элементаў" }, verb: "мець" }, set: { unit: { one: "элемент", few: "элементы", many: "элементаў" }, verb: "мець" }, file: { unit: { one: "байт", few: "байты", many: "байтаў" }, verb: "мець" } }; function t(t) { return e[t] ?? null } const n = { regex: "увод", email: "email адрас", url: "URL", emoji: "эмодзі", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO дата і час", date: "ISO дата", time: "ISO час", duration: "ISO працягласць", ipv4: "IPv4 адрас", ipv6: "IPv6 адрас", cidrv4: "IPv4 дыяпазон", cidrv6: "IPv6 дыяпазон", base64: "радок у фармаце base64", base64url: "радок у фармаце base64url", json_string: "JSON радок", e164: "нумар E.164", jwt: "JWT", template_literal: "увод" }; return e => { switch (e.code) { case "invalid_type": return `Няправільны ўвод: чакаўся ${e.expected}, атрымана ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "лік"; case "object": if (Array.isArray(e)) return "масіў"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Няправільны ўвод: чакалася ${U(e.values[0])}` : `Няправільны варыянт: чакаўся адзін з ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); if (i) { const t = Ci(Number(e.maximum), i.unit.one, i.unit.few, i.unit.many); return `Занадта вялікі: чакалася, што ${e.origin ?? "значэнне"} павінна ${i.verb} ${n}${e.maximum.toString()} ${t}` } return `Занадта вялікі: чакалася, што ${e.origin ?? "значэнне"} павінна быць ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); if (i) { const t = Ci(Number(e.minimum), i.unit.one, i.unit.few, i.unit.many); return `Занадта малы: чакалася, што ${e.origin} павінна ${i.verb} ${n}${e.minimum.toString()} ${t}` } return `Занадта малы: чакалася, што ${e.origin} павінна быць ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Няправільны радок: павінен пачынацца з "${t.prefix}"` : "ends_with" === t.format ? `Няправільны радок: павінен заканчвацца на "${t.suffix}"` : "includes" === t.format ? `Няправільны радок: павінен змяшчаць "${t.includes}"` : "regex" === t.format ? `Няправільны радок: павінен адпавядаць шаблону ${t.pattern}` : `Няправільны ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Няправільны лік: павінен быць кратным ${e.divisor}`; case "unrecognized_keys": return `Нераспазнаны ${e.keys.length > 1 ? "ключы" : "ключ"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Няправільны ключ у ${e.origin}`; case "invalid_union": default: return "Няправільны ўвод"; case "invalid_element": return `Няправільнае значэнне ў ${e.origin}` } } }; const Fi = () => { const e = { string: { unit: "символа", verb: "да съдържа" }, file: { unit: "байта", verb: "да съдържа" }, array: { unit: "елемента", verb: "да съдържа" }, set: { unit: "елемента", verb: "да съдържа" } }; function t(t) { return e[t] ?? null } const n = { regex: "вход", email: "имейл адрес", url: "URL", emoji: "емоджи", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO време", date: "ISO дата", time: "ISO време", duration: "ISO продължителност", ipv4: "IPv4 адрес", ipv6: "IPv6 адрес", cidrv4: "IPv4 диапазон", cidrv6: "IPv6 диапазон", base64: "base64-кодиран низ", base64url: "base64url-кодиран низ", json_string: "JSON низ", e164: "E.164 номер", jwt: "JWT", template_literal: "вход" }; return e => { switch (e.code) { case "invalid_type": return `Невалиден вход: очакван ${e.expected}, получен ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "число"; case "object": if (Array.isArray(e)) return "масив"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Невалиден вход: очакван ${U(e.values[0])}` : `Невалидна опция: очаквано едно от ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Твърде голямо: очаква се ${e.origin ?? "стойност"} да съдържа ${n}${e.maximum.toString()} ${i.unit ?? "елемента"}` : `Твърде голямо: очаква се ${e.origin ?? "стойност"} да бъде ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Твърде малко: очаква се ${e.origin} да съдържа ${n}${e.minimum.toString()} ${i.unit}` : `Твърде малко: очаква се ${e.origin} да бъде ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; if ("starts_with" === t.format) return `Невалиден низ: трябва да започва с "${t.prefix}"`; if ("ends_with" === t.format) return `Невалиден низ: трябва да завършва с "${t.suffix}"`; if ("includes" === t.format) return `Невалиден низ: трябва да включва "${t.includes}"`; if ("regex" === t.format) return `Невалиден низ: трябва да съвпада с ${t.pattern}`; let i = "Невалиден"; return "emoji" === t.format && (i = "Невалидно"), "datetime" === t.format && (i = "Невалидно"), "date" === t.format && (i = "Невалидна"), "time" === t.format && (i = "Невалидно"), "duration" === t.format && (i = "Невалидна"), `${i} ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Невалидно число: трябва да бъде кратно на ${e.divisor}`; case "unrecognized_keys": return `Неразпознат${e.keys.length > 1 ? "и" : ""} ключ${e.keys.length > 1 ? "ове" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Невалиден ключ в ${e.origin}`; case "invalid_union": default: return "Невалиден вход"; case "invalid_element": return `Невалидна стойност в ${e.origin}` } } }; const Ji = () => { const e = { string: { unit: "caràcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } }; function t(t) { return e[t] ?? null } const n = { regex: "entrada", email: "adreça electrònica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adreça IPv4", ipv6: "adreça IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "número E.164", jwt: "JWT", template_literal: "entrada" }; return e => { switch (e.code) { case "invalid_type": return `Tipus invàlid: s'esperava ${e.expected}, s'ha rebut ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Valor invàlid: s'esperava ${U(e.values[0])}` : `Opció invàlida: s'esperava una de ${u(e.values, " o ")}`; case "too_big": { const n = e.inclusive ? "com a màxim" : "menys de", i = t(e.origin); return i ? `Massa gran: s'esperava que ${e.origin ?? "el valor"} contingués ${n} ${e.maximum.toString()} ${i.unit ?? "elements"}` : `Massa gran: s'esperava que ${e.origin ?? "el valor"} fos ${n} ${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? "com a mínim" : "més de", i = t(e.origin); return i ? `Massa petit: s'esperava que ${e.origin} contingués ${n} ${e.minimum.toString()} ${i.unit}` : `Massa petit: s'esperava que ${e.origin} fos ${n} ${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Format invàlid: ha de començar amb "${t.prefix}"` : "ends_with" === t.format ? `Format invàlid: ha d'acabar amb "${t.suffix}"` : "includes" === t.format ? `Format invàlid: ha d'incloure "${t.includes}"` : "regex" === t.format ? `Format invàlid: ha de coincidir amb el patró ${t.pattern}` : `Format invàlid per a ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Número invàlid: ha de ser múltiple de ${e.divisor}`; case "unrecognized_keys": return `Clau${e.keys.length > 1 ? "s" : ""} no reconeguda${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Clau invàlida a ${e.origin}`; case "invalid_union": default: return "Entrada invàlida"; case "invalid_element": return `Element invàlid a ${e.origin}` } } }; const Mi = () => { const e = { string: { unit: "znaků", verb: "mít" }, file: { unit: "bajtů", verb: "mít" }, array: { unit: "prvků", verb: "mít" }, set: { unit: "prvků", verb: "mít" } }; function t(t) { return e[t] ?? null } const n = { regex: "regulární výraz", email: "e-mailová adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a čas ve formátu ISO", date: "datum ve formátu ISO", time: "čas ve formátu ISO", duration: "doba trvání ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "řetězec zakódovaný ve formátu base64", base64url: "řetězec zakódovaný ve formátu base64url", json_string: "řetězec ve formátu JSON", e164: "číslo E.164", jwt: "JWT", template_literal: "vstup" }; return e => { switch (e.code) { case "invalid_type": return `Neplatný vstup: očekáváno ${e.expected}, obdrženo ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "číslo"; case "string": return "řetězec"; case "boolean": return "boolean"; case "bigint": return "bigint"; case "function": return "funkce"; case "symbol": return "symbol"; case "undefined": return "undefined"; case "object": if (Array.isArray(e)) return "pole"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Neplatný vstup: očekáváno ${U(e.values[0])}` : `Neplatná možnost: očekávána jedna z hodnot ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Hodnota je příliš velká: ${e.origin ?? "hodnota"} musí mít ${n}${e.maximum.toString()} ${i.unit ?? "prvků"}` : `Hodnota je příliš velká: ${e.origin ?? "hodnota"} musí být ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Hodnota je příliš malá: ${e.origin ?? "hodnota"} musí mít ${n}${e.minimum.toString()} ${i.unit ?? "prvků"}` : `Hodnota je příliš malá: ${e.origin ?? "hodnota"} musí být ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Neplatný řetězec: musí začínat na "${t.prefix}"` : "ends_with" === t.format ? `Neplatný řetězec: musí končit na "${t.suffix}"` : "includes" === t.format ? `Neplatný řetězec: musí obsahovat "${t.includes}"` : "regex" === t.format ? `Neplatný řetězec: musí odpovídat vzoru ${t.pattern}` : `Neplatný formát ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Neplatné číslo: musí být násobkem ${e.divisor}`; case "unrecognized_keys": return `Neznámé klíče: ${u(e.keys, ", ")}`; case "invalid_key": return `Neplatný klíč v ${e.origin}`; case "invalid_union": default: return "Neplatný vstup"; case "invalid_element": return `Neplatná hodnota v ${e.origin}` } } }; const Wi = () => { const e = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } }, t = { string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "sæt", file: "fil" }; function n(t) { return e[t] ?? null } function i(e) { return t[e] ?? e } const r = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslæt", date: "ISO-dato", time: "ISO-klokkeslæt", duration: "ISO-varighed", ipv4: "IPv4-område", ipv6: "IPv6-område", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Ugyldigt input: forventede ${i(e.expected)}, fik ${i((e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "tal"; case "object": return Array.isArray(e) ? "liste" : null === e ? "null" : Object.getPrototypeOf(e) !== Object.prototype && e.constructor ? e.constructor.name : "objekt" }return t })(e.input))}`; case "invalid_value": return 1 === e.values.length ? `Ugyldig værdi: forventede ${U(e.values[0])}` : `Ugyldigt valg: forventede en af følgende ${u(e.values, "|")}`; case "too_big": { const t = e.inclusive ? "<=" : "<", r = n(e.origin), a = i(e.origin); return r ? `For stor: forventede ${a ?? "value"} ${r.verb} ${t} ${e.maximum.toString()} ${r.unit ?? "elementer"}` : `For stor: forventede ${a ?? "value"} havde ${t} ${e.maximum.toString()}` } case "too_small": { const t = e.inclusive ? ">=" : ">", r = n(e.origin), a = i(e.origin); return r ? `For lille: forventede ${a} ${r.verb} ${t} ${e.minimum.toString()} ${r.unit}` : `For lille: forventede ${a} havde ${t} ${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ugyldig streng: skal starte med "${t.prefix}"` : "ends_with" === t.format ? `Ugyldig streng: skal ende med "${t.suffix}"` : "includes" === t.format ? `Ugyldig streng: skal indeholde "${t.includes}"` : "regex" === t.format ? `Ugyldig streng: skal matche mønsteret ${t.pattern}` : `Ugyldig ${r[t.format] ?? e.format}` } case "not_multiple_of": return `Ugyldigt tal: skal være deleligt med ${e.divisor}`; case "unrecognized_keys": return `${e.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Ugyldig nøgle i ${e.origin}`; case "invalid_union": return "Ugyldigt input: matcher ingen af de tilladte typer"; case "invalid_element": return `Ugyldig værdi i ${e.origin}`; default: return "Ugyldigt input" } } }; const Gi = () => { const e = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } }; function t(t) { return e[t] ?? null } const n = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }; return e => { switch (e.code) { case "invalid_type": return `Ungültige Eingabe: erwartet ${e.expected}, erhalten ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "Zahl"; case "object": if (Array.isArray(e)) return "Array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Ungültige Eingabe: erwartet ${U(e.values[0])}` : `Ungültige Option: erwartet eine von ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Zu groß: erwartet, dass ${e.origin ?? "Wert"} ${n}${e.maximum.toString()} ${i.unit ?? "Elemente"} hat` : `Zu groß: erwartet, dass ${e.origin ?? "Wert"} ${n}${e.maximum.toString()} ist` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Zu klein: erwartet, dass ${e.origin} ${n}${e.minimum.toString()} ${i.unit} hat` : `Zu klein: erwartet, dass ${e.origin} ${n}${e.minimum.toString()} ist` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ungültiger String: muss mit "${t.prefix}" beginnen` : "ends_with" === t.format ? `Ungültiger String: muss mit "${t.suffix}" enden` : "includes" === t.format ? `Ungültiger String: muss "${t.includes}" enthalten` : "regex" === t.format ? `Ungültiger String: muss dem Muster ${t.pattern} entsprechen` : `Ungültig: ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Ungültige Zahl: muss ein Vielfaches von ${e.divisor} sein`; case "unrecognized_keys": return `${e.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Ungültiger Schlüssel in ${e.origin}`; case "invalid_union": default: return "Ungültige Eingabe"; case "invalid_element": return `Ungültiger Wert in ${e.origin}` } } }; const Vi = () => { const e = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } }; function t(t) { return e[t] ?? null } const n = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Invalid input: expected ${e.expected}, received ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Invalid input: expected ${U(e.values[0])}` : `Invalid option: expected one of ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Too big: expected ${e.origin ?? "value"} to have ${n}${e.maximum.toString()} ${i.unit ?? "elements"}` : `Too big: expected ${e.origin ?? "value"} to be ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Too small: expected ${e.origin} to have ${n}${e.minimum.toString()} ${i.unit}` : `Too small: expected ${e.origin} to be ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Invalid string: must start with "${t.prefix}"` : "ends_with" === t.format ? `Invalid string: must end with "${t.suffix}"` : "includes" === t.format ? `Invalid string: must include "${t.includes}"` : "regex" === t.format ? `Invalid string: must match pattern ${t.pattern}` : `Invalid ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Invalid number: must be a multiple of ${e.divisor}`; case "unrecognized_keys": return `Unrecognized key${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Invalid key in ${e.origin}`; case "invalid_union": default: return "Invalid input"; case "invalid_element": return `Invalid value in ${e.origin}` } } }; function Ki() { return { localeError: Vi() } } const Bi = () => { const e = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } }; function t(t) { return e[t] ?? null } const n = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoĝio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daŭro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }; return e => { switch (e.code) { case "invalid_type": return `Nevalida enigo: atendiĝis ${e.expected}, riceviĝis ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "nombro"; case "object": if (Array.isArray(e)) return "tabelo"; if (null === e) return "senvalora"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Nevalida enigo: atendiĝis ${U(e.values[0])}` : `Nevalida opcio: atendiĝis unu el ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Tro granda: atendiĝis ke ${e.origin ?? "valoro"} havu ${n}${e.maximum.toString()} ${i.unit ?? "elementojn"}` : `Tro granda: atendiĝis ke ${e.origin ?? "valoro"} havu ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Tro malgranda: atendiĝis ke ${e.origin} havu ${n}${e.minimum.toString()} ${i.unit}` : `Tro malgranda: atendiĝis ke ${e.origin} estu ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Nevalida karaktraro: devas komenciĝi per "${t.prefix}"` : "ends_with" === t.format ? `Nevalida karaktraro: devas finiĝi per "${t.suffix}"` : "includes" === t.format ? `Nevalida karaktraro: devas inkluzivi "${t.includes}"` : "regex" === t.format ? `Nevalida karaktraro: devas kongrui kun la modelo ${t.pattern}` : `Nevalida ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Nevalida nombro: devas esti oblo de ${e.divisor}`; case "unrecognized_keys": return `Nekonata${e.keys.length > 1 ? "j" : ""} ŝlosilo${e.keys.length > 1 ? "j" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Nevalida ŝlosilo en ${e.origin}`; case "invalid_union": default: return "Nevalida enigo"; case "invalid_element": return `Nevalida valoro en ${e.origin}` } } }; const Xi = () => { const e = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } }, t = { string: "texto", number: "número", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "número grande", symbol: "símbolo", undefined: "indefinido", null: "nulo", function: "función", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeración", union: "unión", literal: "literal", promise: "promesa", void: "vacío", never: "nunca", unknown: "desconocido", any: "cualquiera" }; function n(t) { return e[t] ?? null } function i(e) { return t[e] ?? e } const r = { regex: "entrada", email: "dirección de correo electrónico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duración ISO", ipv4: "dirección IPv4", ipv6: "dirección IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "número E.164", jwt: "JWT", template_literal: "entrada" }; return e => { switch (e.code) { case "invalid_type": return `Entrada inválida: se esperaba ${i(e.expected)}, recibido ${i((e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": return Array.isArray(e) ? "array" : null === e ? "null" : Object.getPrototypeOf(e) !== Object.prototype ? e.constructor.name : "object" }return t })(e.input))}`; case "invalid_value": return 1 === e.values.length ? `Entrada inválida: se esperaba ${U(e.values[0])}` : `Opción inválida: se esperaba una de ${u(e.values, "|")}`; case "too_big": { const t = e.inclusive ? "<=" : "<", r = n(e.origin), a = i(e.origin); return r ? `Demasiado grande: se esperaba que ${a ?? "valor"} tuviera ${t}${e.maximum.toString()} ${r.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${a ?? "valor"} fuera ${t}${e.maximum.toString()}` } case "too_small": { const t = e.inclusive ? ">=" : ">", r = n(e.origin), a = i(e.origin); return r ? `Demasiado pequeño: se esperaba que ${a} tuviera ${t}${e.minimum.toString()} ${r.unit}` : `Demasiado pequeño: se esperaba que ${a} fuera ${t}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Cadena inválida: debe comenzar con "${t.prefix}"` : "ends_with" === t.format ? `Cadena inválida: debe terminar en "${t.suffix}"` : "includes" === t.format ? `Cadena inválida: debe incluir "${t.includes}"` : "regex" === t.format ? `Cadena inválida: debe coincidir con el patrón ${t.pattern}` : `Inválido ${r[t.format] ?? e.format}` } case "not_multiple_of": return `Número inválido: debe ser múltiplo de ${e.divisor}`; case "unrecognized_keys": return `Llave${e.keys.length > 1 ? "s" : ""} desconocida${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Llave inválida en ${i(e.origin)}`; case "invalid_union": default: return "Entrada inválida"; case "invalid_element": return `Valor inválido en ${i(e.origin)}` } } }; const qi = () => { const e = { string: { unit: "کاراکتر", verb: "داشته باشد" }, file: { unit: "بایت", verb: "داشته باشد" }, array: { unit: "آیتم", verb: "داشته باشد" }, set: { unit: "آیتم", verb: "داشته باشد" } }; function t(t) { return e[t] ?? null } const n = { regex: "ورودی", email: "آدرس ایمیل", url: "URL", emoji: "ایموجی", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "تاریخ و زمان ایزو", date: "تاریخ ایزو", time: "زمان ایزو", duration: "مدت زمان ایزو", ipv4: "IPv4 آدرس", ipv6: "IPv6 آدرس", cidrv4: "IPv4 دامنه", cidrv6: "IPv6 دامنه", base64: "base64-encoded رشته", base64url: "base64url-encoded رشته", json_string: "JSON رشته", e164: "E.164 عدد", jwt: "JWT", template_literal: "ورودی" }; return e => { switch (e.code) { case "invalid_type": return `ورودی نامعتبر: می‌بایست ${e.expected} می‌بود، ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "عدد"; case "object": if (Array.isArray(e)) return "آرایه"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)} دریافت شد`; case "invalid_value": return 1 === e.values.length ? `ورودی نامعتبر: می‌بایست ${U(e.values[0])} می‌بود` : `گزینه نامعتبر: می‌بایست یکی از ${u(e.values, "|")} می‌بود`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `خیلی بزرگ: ${e.origin ?? "مقدار"} باید ${n}${e.maximum.toString()} ${i.unit ?? "عنصر"} باشد` : `خیلی بزرگ: ${e.origin ?? "مقدار"} باید ${n}${e.maximum.toString()} باشد` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `خیلی کوچک: ${e.origin} باید ${n}${e.minimum.toString()} ${i.unit} باشد` : `خیلی کوچک: ${e.origin} باید ${n}${e.minimum.toString()} باشد` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `رشته نامعتبر: باید با "${t.prefix}" شروع شود` : "ends_with" === t.format ? `رشته نامعتبر: باید با "${t.suffix}" تمام شود` : "includes" === t.format ? `رشته نامعتبر: باید شامل "${t.includes}" باشد` : "regex" === t.format ? `رشته نامعتبر: باید با الگوی ${t.pattern} مطابقت داشته باشد` : `${n[t.format] ?? e.format} نامعتبر` } case "not_multiple_of": return `عدد نامعتبر: باید مضرب ${e.divisor} باشد`; case "unrecognized_keys": return `کلید${e.keys.length > 1 ? "های" : ""} ناشناس: ${u(e.keys, ", ")}`; case "invalid_key": return `کلید ناشناس در ${e.origin}`; case "invalid_union": default: return "ورودی نامعتبر"; case "invalid_element": return `مقدار نامعتبر در ${e.origin}` } } }; const Yi = () => { const e = { string: { unit: "merkkiä", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "päivämäärän" } }; function t(t) { return e[t] ?? null } const n = { regex: "säännöllinen lauseke", email: "sähköpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-päivämäärä", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }; return e => { switch (e.code) { case "invalid_type": return `Virheellinen tyyppi: odotettiin ${e.expected}, oli ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Virheellinen syöte: täytyy olla ${U(e.values[0])}` : `Virheellinen valinta: täytyy olla yksi seuraavista: ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Liian suuri: ${i.subject} täytyy olla ${n}${e.maximum.toString()} ${i.unit}`.trim() : `Liian suuri: arvon täytyy olla ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Liian pieni: ${i.subject} täytyy olla ${n}${e.minimum.toString()} ${i.unit}`.trim() : `Liian pieni: arvon täytyy olla ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Virheellinen syöte: täytyy alkaa "${t.prefix}"` : "ends_with" === t.format ? `Virheellinen syöte: täytyy loppua "${t.suffix}"` : "includes" === t.format ? `Virheellinen syöte: täytyy sisältää "${t.includes}"` : "regex" === t.format ? `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${t.pattern}` : `Virheellinen ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Virheellinen luku: täytyy olla luvun ${e.divisor} monikerta`; case "unrecognized_keys": return `${e.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${u(e.keys, ", ")}`; case "invalid_key": return "Virheellinen avain tietueessa"; case "invalid_union": return "Virheellinen unioni"; case "invalid_element": return "Virheellinen arvo joukossa"; default: return "Virheellinen syöte" } } }; const Hi = () => { const e = { string: { unit: "caractères", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "éléments", verb: "avoir" }, set: { unit: "éléments", verb: "avoir" } }; function t(t) { return e[t] ?? null } const n = { regex: "entrée", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "durée ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chaîne encodée en base64", base64url: "chaîne encodée en base64url", json_string: "chaîne JSON", e164: "numéro E.164", jwt: "JWT", template_literal: "entrée" }; return e => { switch (e.code) { case "invalid_type": return `Entrée invalide : ${e.expected} attendu, ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "nombre"; case "object": if (Array.isArray(e)) return "tableau"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)} reçu`; case "invalid_value": return 1 === e.values.length ? `Entrée invalide : ${U(e.values[0])} attendu` : `Option invalide : une valeur parmi ${u(e.values, "|")} attendue`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Trop grand : ${e.origin ?? "valeur"} doit ${i.verb} ${n}${e.maximum.toString()} ${i.unit ?? "élément(s)"}` : `Trop grand : ${e.origin ?? "valeur"} doit être ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Trop petit : ${e.origin} doit ${i.verb} ${n}${e.minimum.toString()} ${i.unit}` : `Trop petit : ${e.origin} doit être ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Chaîne invalide : doit commencer par "${t.prefix}"` : "ends_with" === t.format ? `Chaîne invalide : doit se terminer par "${t.suffix}"` : "includes" === t.format ? `Chaîne invalide : doit inclure "${t.includes}"` : "regex" === t.format ? `Chaîne invalide : doit correspondre au modèle ${t.pattern}` : `${n[t.format] ?? e.format} invalide` } case "not_multiple_of": return `Nombre invalide : doit être un multiple de ${e.divisor}`; case "unrecognized_keys": return `Clé${e.keys.length > 1 ? "s" : ""} non reconnue${e.keys.length > 1 ? "s" : ""} : ${u(e.keys, ", ")}`; case "invalid_key": return `Clé invalide dans ${e.origin}`; case "invalid_union": default: return "Entrée invalide"; case "invalid_element": return `Valeur invalide dans ${e.origin}` } } }; const Qi = () => { const e = { string: { unit: "caractères", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "éléments", verb: "avoir" }, set: { unit: "éléments", verb: "avoir" } }; function t(t) { return e[t] ?? null } const n = { regex: "entrée", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "durée ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chaîne encodée en base64", base64url: "chaîne encodée en base64url", json_string: "chaîne JSON", e164: "numéro E.164", jwt: "JWT", template_literal: "entrée" }; return e => { switch (e.code) { case "invalid_type": return `Entrée invalide : attendu ${e.expected}, reçu ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Entrée invalide : attendu ${U(e.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "≤" : "<", i = t(e.origin); return i ? `Trop grand : attendu que ${e.origin ?? "la valeur"} ait ${n}${e.maximum.toString()} ${i.unit}` : `Trop grand : attendu que ${e.origin ?? "la valeur"} soit ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? "≥" : ">", i = t(e.origin); return i ? `Trop petit : attendu que ${e.origin} ait ${n}${e.minimum.toString()} ${i.unit}` : `Trop petit : attendu que ${e.origin} soit ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Chaîne invalide : doit commencer par "${t.prefix}"` : "ends_with" === t.format ? `Chaîne invalide : doit se terminer par "${t.suffix}"` : "includes" === t.format ? `Chaîne invalide : doit inclure "${t.includes}"` : "regex" === t.format ? `Chaîne invalide : doit correspondre au motif ${t.pattern}` : `${n[t.format] ?? e.format} invalide` } case "not_multiple_of": return `Nombre invalide : doit être un multiple de ${e.divisor}`; case "unrecognized_keys": return `Clé${e.keys.length > 1 ? "s" : ""} non reconnue${e.keys.length > 1 ? "s" : ""} : ${u(e.keys, ", ")}`; case "invalid_key": return `Clé invalide dans ${e.origin}`; case "invalid_union": default: return "Entrée invalide"; case "invalid_element": return `Valeur invalide dans ${e.origin}` } } }; const er = () => { const e = { string: { unit: "אותיות", verb: "לכלול" }, file: { unit: "בייטים", verb: "לכלול" }, array: { unit: "פריטים", verb: "לכלול" }, set: { unit: "פריטים", verb: "לכלול" } }; function t(t) { return e[t] ?? null } const n = { regex: "קלט", email: "כתובת אימייל", url: "כתובת רשת", emoji: "אימוג'י", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "תאריך וזמן ISO", date: "תאריך ISO", time: "זמן ISO", duration: "משך זמן ISO", ipv4: "כתובת IPv4", ipv6: "כתובת IPv6", cidrv4: "טווח IPv4", cidrv6: "טווח IPv6", base64: "מחרוזת בבסיס 64", base64url: "מחרוזת בבסיס 64 לכתובות רשת", json_string: "מחרוזת JSON", e164: "מספר E.164", jwt: "JWT", template_literal: "קלט" }; return e => { switch (e.code) { case "invalid_type": return `קלט לא תקין: צריך ${e.expected}, התקבל ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `קלט לא תקין: צריך ${U(e.values[0])}` : `קלט לא תקין: צריך אחת מהאפשרויות  ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `גדול מדי: ${e.origin ?? "value"} צריך להיות ${n}${e.maximum.toString()} ${i.unit ?? "elements"}` : `גדול מדי: ${e.origin ?? "value"} צריך להיות ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `קטן מדי: ${e.origin} צריך להיות ${n}${e.minimum.toString()} ${i.unit}` : `קטן מדי: ${e.origin} צריך להיות ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `מחרוזת לא תקינה: חייבת להתחיל ב"${t.prefix}"` : "ends_with" === t.format ? `מחרוזת לא תקינה: חייבת להסתיים ב "${t.suffix}"` : "includes" === t.format ? `מחרוזת לא תקינה: חייבת לכלול "${t.includes}"` : "regex" === t.format ? `מחרוזת לא תקינה: חייבת להתאים לתבנית ${t.pattern}` : `${n[t.format] ?? e.format} לא תקין` } case "not_multiple_of": return `מספר לא תקין: חייב להיות מכפלה של ${e.divisor}`; case "unrecognized_keys": return `מפתח${e.keys.length > 1 ? "ות" : ""} לא מזוה${e.keys.length > 1 ? "ים" : "ה"}: ${u(e.keys, ", ")}`; case "invalid_key": return `מפתח לא תקין ב${e.origin}`; case "invalid_union": default: return "קלט לא תקין"; case "invalid_element": return `ערך לא תקין ב${e.origin}` } } }; const tr = () => { const e = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } }; function t(t) { return e[t] ?? null } const n = { regex: "bemenet", email: "email cím", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO időbélyeg", date: "ISO dátum", time: "ISO idő", duration: "ISO időintervallum", ipv4: "IPv4 cím", ipv6: "IPv6 cím", cidrv4: "IPv4 tartomány", cidrv6: "IPv6 tartomány", base64: "base64-kódolt string", base64url: "base64url-kódolt string", json_string: "JSON string", e164: "E.164 szám", jwt: "JWT", template_literal: "bemenet" }; return e => { switch (e.code) { case "invalid_type": return `Érvénytelen bemenet: a várt érték ${e.expected}, a kapott érték ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "szám"; case "object": if (Array.isArray(e)) return "tömb"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Érvénytelen bemenet: a várt érték ${U(e.values[0])}` : `Érvénytelen opció: valamelyik érték várt ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Túl nagy: ${e.origin ?? "érték"} mérete túl nagy ${n}${e.maximum.toString()} ${i.unit ?? "elem"}` : `Túl nagy: a bemeneti érték ${e.origin ?? "érték"} túl nagy: ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Túl kicsi: a bemeneti érték ${e.origin} mérete túl kicsi ${n}${e.minimum.toString()} ${i.unit}` : `Túl kicsi: a bemeneti érték ${e.origin} túl kicsi ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Érvénytelen string: "${t.prefix}" értékkel kell kezdődnie` : "ends_with" === t.format ? `Érvénytelen string: "${t.suffix}" értékkel kell végződnie` : "includes" === t.format ? `Érvénytelen string: "${t.includes}" értéket kell tartalmaznia` : "regex" === t.format ? `Érvénytelen string: ${t.pattern} mintának kell megfelelnie` : `Érvénytelen ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Érvénytelen szám: ${e.divisor} többszörösének kell lennie`; case "unrecognized_keys": return `Ismeretlen kulcs${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Érvénytelen kulcs ${e.origin}`; case "invalid_union": default: return "Érvénytelen bemenet"; case "invalid_element": return `Érvénytelen érték: ${e.origin}` } } }; const nr = () => { const e = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } }; function t(t) { return e[t] ?? null } const n = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Input tidak valid: diharapkan ${e.expected}, diterima ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Input tidak valid: diharapkan ${U(e.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Terlalu besar: diharapkan ${e.origin ?? "value"} memiliki ${n}${e.maximum.toString()} ${i.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${e.origin ?? "value"} menjadi ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Terlalu kecil: diharapkan ${e.origin} memiliki ${n}${e.minimum.toString()} ${i.unit}` : `Terlalu kecil: diharapkan ${e.origin} menjadi ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `String tidak valid: harus dimulai dengan "${t.prefix}"` : "ends_with" === t.format ? `String tidak valid: harus berakhir dengan "${t.suffix}"` : "includes" === t.format ? `String tidak valid: harus menyertakan "${t.includes}"` : "regex" === t.format ? `String tidak valid: harus sesuai pola ${t.pattern}` : `${n[t.format] ?? e.format} tidak valid` } case "not_multiple_of": return `Angka tidak valid: harus kelipatan dari ${e.divisor}`; case "unrecognized_keys": return `Kunci tidak dikenali ${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Kunci tidak valid di ${e.origin}`; case "invalid_union": default: return "Input tidak valid"; case "invalid_element": return `Nilai tidak valid di ${e.origin}` } } }; const ir = () => { const e = { string: { unit: "stafi", verb: "að hafa" }, file: { unit: "bæti", verb: "að hafa" }, array: { unit: "hluti", verb: "að hafa" }, set: { unit: "hluti", verb: "að hafa" } }; function t(t) { return e[t] ?? null } const n = { regex: "gildi", email: "netfang", url: "vefslóð", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tími", date: "ISO dagsetning", time: "ISO tími", duration: "ISO tímalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tölugildi", jwt: "JWT", template_literal: "gildi" }; return e => { switch (e.code) { case "invalid_type": return `Rangt gildi: Þú slóst inn ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "númer"; case "object": if (Array.isArray(e)) return "fylki"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)} þar sem á að vera ${e.expected}`; case "invalid_value": return 1 === e.values.length ? `Rangt gildi: gert ráð fyrir ${U(e.values[0])}` : `Ógilt val: má vera eitt af eftirfarandi ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Of stórt: gert er ráð fyrir að ${e.origin ?? "gildi"} hafi ${n}${e.maximum.toString()} ${i.unit ?? "hluti"}` : `Of stórt: gert er ráð fyrir að ${e.origin ?? "gildi"} sé ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Of lítið: gert er ráð fyrir að ${e.origin} hafi ${n}${e.minimum.toString()} ${i.unit}` : `Of lítið: gert er ráð fyrir að ${e.origin} sé ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ógildur strengur: verður að byrja á "${t.prefix}"` : "ends_with" === t.format ? `Ógildur strengur: verður að enda á "${t.suffix}"` : "includes" === t.format ? `Ógildur strengur: verður að innihalda "${t.includes}"` : "regex" === t.format ? `Ógildur strengur: verður að fylgja mynstri ${t.pattern}` : `Rangt ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Röng tala: verður að vera margfeldi af ${e.divisor}`; case "unrecognized_keys": return `Óþekkt ${e.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Rangur lykill í ${e.origin}`; case "invalid_union": default: return "Rangt gildi"; case "invalid_element": return `Rangt gildi í ${e.origin}` } } }; const rr = () => { const e = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } }; function t(t) { return e[t] ?? null } const n = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Input non valido: atteso ${e.expected}, ricevuto ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "numero"; case "object": if (Array.isArray(e)) return "vettore"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Input non valido: atteso ${U(e.values[0])}` : `Opzione non valida: atteso uno tra ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Troppo grande: ${e.origin ?? "valore"} deve avere ${n}${e.maximum.toString()} ${i.unit ?? "elementi"}` : `Troppo grande: ${e.origin ?? "valore"} deve essere ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Troppo piccolo: ${e.origin} deve avere ${n}${e.minimum.toString()} ${i.unit}` : `Troppo piccolo: ${e.origin} deve essere ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Stringa non valida: deve iniziare con "${t.prefix}"` : "ends_with" === t.format ? `Stringa non valida: deve terminare con "${t.suffix}"` : "includes" === t.format ? `Stringa non valida: deve includere "${t.includes}"` : "regex" === t.format ? `Stringa non valida: deve corrispondere al pattern ${t.pattern}` : `Invalid ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Numero non valido: deve essere un multiplo di ${e.divisor}`; case "unrecognized_keys": return `Chiav${e.keys.length > 1 ? "i" : "e"} non riconosciut${e.keys.length > 1 ? "e" : "a"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Chiave non valida in ${e.origin}`; case "invalid_union": default: return "Input non valido"; case "invalid_element": return `Valore non valido in ${e.origin}` } } }; const ar = () => { const e = { string: { unit: "文字", verb: "である" }, file: { unit: "バイト", verb: "である" }, array: { unit: "要素", verb: "である" }, set: { unit: "要素", verb: "である" } }; function t(t) { return e[t] ?? null } const n = { regex: "入力値", email: "メールアドレス", url: "URL", emoji: "絵文字", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO日時", date: "ISO日付", time: "ISO時刻", duration: "ISO期間", ipv4: "IPv4アドレス", ipv6: "IPv6アドレス", cidrv4: "IPv4範囲", cidrv6: "IPv6範囲", base64: "base64エンコード文字列", base64url: "base64urlエンコード文字列", json_string: "JSON文字列", e164: "E.164番号", jwt: "JWT", template_literal: "入力値" }; return e => { switch (e.code) { case "invalid_type": return `無効な入力: ${e.expected}が期待されましたが、${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "数値"; case "object": if (Array.isArray(e)) return "配列"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}が入力されました`; case "invalid_value": return 1 === e.values.length ? `無効な入力: ${U(e.values[0])}が期待されました` : `無効な選択: ${u(e.values, "、")}のいずれかである必要があります`; case "too_big": { const n = e.inclusive ? "以下である" : "より小さい", i = t(e.origin); return i ? `大きすぎる値: ${e.origin ?? "値"}は${e.maximum.toString()}${i.unit ?? "要素"}${n}必要があります` : `大きすぎる値: ${e.origin ?? "値"}は${e.maximum.toString()}${n}必要があります` } case "too_small": { const n = e.inclusive ? "以上である" : "より大きい", i = t(e.origin); return i ? `小さすぎる値: ${e.origin}は${e.minimum.toString()}${i.unit}${n}必要があります` : `小さすぎる値: ${e.origin}は${e.minimum.toString()}${n}必要があります` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `無効な文字列: "${t.prefix}"で始まる必要があります` : "ends_with" === t.format ? `無効な文字列: "${t.suffix}"で終わる必要があります` : "includes" === t.format ? `無効な文字列: "${t.includes}"を含む必要があります` : "regex" === t.format ? `無効な文字列: パターン${t.pattern}に一致する必要があります` : `無効な${n[t.format] ?? e.format}` } case "not_multiple_of": return `無効な数値: ${e.divisor}の倍数である必要があります`; case "unrecognized_keys": return `認識されていないキー${e.keys.length > 1 ? "群" : ""}: ${u(e.keys, "、")}`; case "invalid_key": return `${e.origin}内の無効なキー`; case "invalid_union": default: return "無効な入力"; case "invalid_element": return `${e.origin}内の無効な値` } } }; const or = () => { const e = { string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" }, file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" }, array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }, set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" } }; function t(t) { return e[t] ?? null } const n = { regex: "შეყვანა", email: "ელ-ფოსტის მისამართი", url: "URL", emoji: "ემოჯი", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "თარიღი-დრო", date: "თარიღი", time: "დრო", duration: "ხანგრძლივობა", ipv4: "IPv4 მისამართი", ipv6: "IPv6 მისამართი", cidrv4: "IPv4 დიაპაზონი", cidrv6: "IPv6 დიაპაზონი", base64: "base64-კოდირებული სტრინგი", base64url: "base64url-კოდირებული სტრინგი", json_string: "JSON სტრინგი", e164: "E.164 ნომერი", jwt: "JWT", template_literal: "შეყვანა" }; return e => { switch (e.code) { case "invalid_type": return `არასწორი შეყვანა: მოსალოდნელი ${e.expected}, მიღებული ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "რიცხვი"; case "object": if (Array.isArray(e)) return "მასივი"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return { string: "სტრინგი", boolean: "ბულეანი", undefined: "undefined", bigint: "bigint", symbol: "symbol", function: "ფუნქცია" }[t] ?? t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `არასწორი შეყვანა: მოსალოდნელი ${U(e.values[0])}` : `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${u(e.values, "|")}-დან`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `ზედმეტად დიდი: მოსალოდნელი ${e.origin ?? "მნიშვნელობა"} ${i.verb} ${n}${e.maximum.toString()} ${i.unit}` : `ზედმეტად დიდი: მოსალოდნელი ${e.origin ?? "მნიშვნელობა"} იყოს ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `ზედმეტად პატარა: მოსალოდნელი ${e.origin} ${i.verb} ${n}${e.minimum.toString()} ${i.unit}` : `ზედმეტად პატარა: მოსალოდნელი ${e.origin} იყოს ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `არასწორი სტრინგი: უნდა იწყებოდეს "${t.prefix}"-ით` : "ends_with" === t.format ? `არასწორი სტრინგი: უნდა მთავრდებოდეს "${t.suffix}"-ით` : "includes" === t.format ? `არასწორი სტრინგი: უნდა შეიცავდეს "${t.includes}"-ს` : "regex" === t.format ? `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${t.pattern}` : `არასწორი ${n[t.format] ?? e.format}` } case "not_multiple_of": return `არასწორი რიცხვი: უნდა იყოს ${e.divisor}-ის ჯერადი`; case "unrecognized_keys": return `უცნობი გასაღებ${e.keys.length > 1 ? "ები" : "ი"}: ${u(e.keys, ", ")}`; case "invalid_key": return `არასწორი გასაღები ${e.origin}-ში`; case "invalid_union": default: return "არასწორი შეყვანა"; case "invalid_element": return `არასწორი მნიშვნელობა ${e.origin}-ში` } } }; const sr = () => { const e = { string: { unit: "តួអក្សរ", verb: "គួរមាន" }, file: { unit: "បៃ", verb: "គួរមាន" }, array: { unit: "ធាតុ", verb: "គួរមាន" }, set: { unit: "ធាតុ", verb: "គួរមាន" } }; function t(t) { return e[t] ?? null } const n = { regex: "ទិន្នន័យបញ្ចូល", email: "អាសយដ្ឋានអ៊ីមែល", url: "URL", emoji: "សញ្ញាអារម្មណ៍", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO", date: "កាលបរិច្ឆេទ ISO", time: "ម៉ោង ISO", duration: "រយៈពេល ISO", ipv4: "អាសយដ្ឋាន IPv4", ipv6: "អាសយដ្ឋាន IPv6", cidrv4: "ដែនអាសយដ្ឋាន IPv4", cidrv6: "ដែនអាសយដ្ឋាន IPv6", base64: "ខ្សែអក្សរអ៊ិកូដ base64", base64url: "ខ្សែអក្សរអ៊ិកូដ base64url", json_string: "ខ្សែអក្សរ JSON", e164: "លេខ E.164", jwt: "JWT", template_literal: "ទិន្នន័យបញ្ចូល" }; return e => { switch (e.code) { case "invalid_type": return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${e.expected} ប៉ុន្តែទទួលបាន ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "មិនមែនជាលេខ (NaN)" : "លេខ"; case "object": if (Array.isArray(e)) return "អារេ (Array)"; if (null === e) return "គ្មានតម្លៃ (null)"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${U(e.values[0])}` : `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `ធំពេក៖ ត្រូវការ ${e.origin ?? "តម្លៃ"} ${n} ${e.maximum.toString()} ${i.unit ?? "ធាតុ"}` : `ធំពេក៖ ត្រូវការ ${e.origin ?? "តម្លៃ"} ${n} ${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `តូចពេក៖ ត្រូវការ ${e.origin} ${n} ${e.minimum.toString()} ${i.unit}` : `តូចពេក៖ ត្រូវការ ${e.origin} ${n} ${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${t.prefix}"` : "ends_with" === t.format ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${t.suffix}"` : "includes" === t.format ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${t.includes}"` : "regex" === t.format ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${t.pattern}` : `មិនត្រឹមត្រូវ៖ ${n[t.format] ?? e.format}` } case "not_multiple_of": return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${e.divisor}`; case "unrecognized_keys": return `រកឃើញសោមិនស្គាល់៖ ${u(e.keys, ", ")}`; case "invalid_key": return `សោមិនត្រឹមត្រូវនៅក្នុង ${e.origin}`; case "invalid_union": default: return "ទិន្នន័យមិនត្រឹមត្រូវ"; case "invalid_element": return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${e.origin}` } } }; function ur() { return { localeError: sr() } } const cr = () => { const e = { string: { unit: "문자", verb: "to have" }, file: { unit: "바이트", verb: "to have" }, array: { unit: "개", verb: "to have" }, set: { unit: "개", verb: "to have" } }; function t(t) { return e[t] ?? null } const n = { regex: "입력", email: "이메일 주소", url: "URL", emoji: "이모지", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO 날짜시간", date: "ISO 날짜", time: "ISO 시간", duration: "ISO 기간", ipv4: "IPv4 주소", ipv6: "IPv6 주소", cidrv4: "IPv4 범위", cidrv6: "IPv6 범위", base64: "base64 인코딩 문자열", base64url: "base64url 인코딩 문자열", json_string: "JSON 문자열", e164: "E.164 번호", jwt: "JWT", template_literal: "입력" }; return e => { switch (e.code) { case "invalid_type": return `잘못된 입력: 예상 타입은 ${e.expected}, 받은 타입은 ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}입니다`; case "invalid_value": return 1 === e.values.length ? `잘못된 입력: 값은 ${U(e.values[0])} 이어야 합니다` : `잘못된 옵션: ${u(e.values, "또는 ")} 중 하나여야 합니다`; case "too_big": { const n = e.inclusive ? "이하" : "미만", i = "미만" === n ? "이어야 합니다" : "여야 합니다", r = t(e.origin), a = r?.unit ?? "요소"; return r ? `${e.origin ?? "값"}이 너무 큽니다: ${e.maximum.toString()}${a} ${n}${i}` : `${e.origin ?? "값"}이 너무 큽니다: ${e.maximum.toString()} ${n}${i}` } case "too_small": { const n = e.inclusive ? "이상" : "초과", i = "이상" === n ? "이어야 합니다" : "여야 합니다", r = t(e.origin), a = r?.unit ?? "요소"; return r ? `${e.origin ?? "값"}이 너무 작습니다: ${e.minimum.toString()}${a} ${n}${i}` : `${e.origin ?? "값"}이 너무 작습니다: ${e.minimum.toString()} ${n}${i}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `잘못된 문자열: "${t.prefix}"(으)로 시작해야 합니다` : "ends_with" === t.format ? `잘못된 문자열: "${t.suffix}"(으)로 끝나야 합니다` : "includes" === t.format ? `잘못된 문자열: "${t.includes}"을(를) 포함해야 합니다` : "regex" === t.format ? `잘못된 문자열: 정규식 ${t.pattern} 패턴과 일치해야 합니다` : `잘못된 ${n[t.format] ?? e.format}` } case "not_multiple_of": return `잘못된 숫자: ${e.divisor}의 배수여야 합니다`; case "unrecognized_keys": return `인식할 수 없는 키: ${u(e.keys, ", ")}`; case "invalid_key": return `잘못된 키: ${e.origin}`; case "invalid_union": default: return "잘못된 입력"; case "invalid_element": return `잘못된 값: ${e.origin}` } } }; const lr = (e, t = void 0) => { switch (e) { case "number": return Number.isNaN(t) ? "NaN" : "skaičius"; case "bigint": return "sveikasis skaičius"; case "string": return "eilutė"; case "boolean": return "loginė reikšmė"; case "undefined": case "void": return "neapibrėžta reikšmė"; case "function": return "funkcija"; case "symbol": return "simbolis"; case "object": return void 0 === t ? "nežinomas objektas" : null === t ? "nulinė reikšmė" : Array.isArray(t) ? "masyvas" : Object.getPrototypeOf(t) !== Object.prototype && t.constructor ? t.constructor.name : "objektas"; case "null": return "nulinė reikšmė" }return e }, dr = e => e.charAt(0).toUpperCase() + e.slice(1); function mr(e) { const t = Math.abs(e), n = t % 10, i = t % 100; return i >= 11 && i <= 19 || 0 === n ? "many" : 1 === n ? "one" : "few" } const pr = () => { const e = { string: { unit: { one: "simbolis", few: "simboliai", many: "simbolių" }, verb: { smaller: { inclusive: "turi būti ne ilgesnė kaip", notInclusive: "turi būti trumpesnė kaip" }, bigger: { inclusive: "turi būti ne trumpesnė kaip", notInclusive: "turi būti ilgesnė kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "baitų" }, verb: { smaller: { inclusive: "turi būti ne didesnis kaip", notInclusive: "turi būti mažesnis kaip" }, bigger: { inclusive: "turi būti ne mažesnis kaip", notInclusive: "turi būti didesnis kaip" } } }, array: { unit: { one: "elementą", few: "elementus", many: "elementų" }, verb: { smaller: { inclusive: "turi turėti ne daugiau kaip", notInclusive: "turi turėti mažiau kaip" }, bigger: { inclusive: "turi turėti ne mažiau kaip", notInclusive: "turi turėti daugiau kaip" } } }, set: { unit: { one: "elementą", few: "elementus", many: "elementų" }, verb: { smaller: { inclusive: "turi turėti ne daugiau kaip", notInclusive: "turi turėti mažiau kaip" }, bigger: { inclusive: "turi turėti ne mažiau kaip", notInclusive: "turi turėti daugiau kaip" } } } }; function t(t, n, i, r) { const a = e[t] ?? null; return null === a ? a : { unit: a.unit[n], verb: a.verb[r][i ? "inclusive" : "notInclusive"] } } const n = { regex: "įvestis", email: "el. pašto adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukmė", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 užkoduota eilutė", base64url: "base64url užkoduota eilutė", json_string: "JSON eilutė", e164: "E.164 numeris", jwt: "JWT", template_literal: "įvestis" }; return e => { switch (e.code) { case "invalid_type": return `Gautas tipas ${i = e.input, lr(typeof i, i)}, o tikėtasi - ${lr(e.expected)}`; case "invalid_value": return 1 === e.values.length ? `Privalo būti ${U(e.values[0])}` : `Privalo būti vienas iš ${u(e.values, "|")} pasirinkimų`; case "too_big": { const n = lr(e.origin), i = t(e.origin, mr(Number(e.maximum)), e.inclusive ?? !1, "smaller"); if (i?.verb) return `${dr(n ?? e.origin ?? "reikšmė")} ${i.verb} ${e.maximum.toString()} ${i.unit ?? "elementų"}`; const r = e.inclusive ? "ne didesnis kaip" : "mažesnis kaip"; return `${dr(n ?? e.origin ?? "reikšmė")} turi būti ${r} ${e.maximum.toString()} ${i?.unit}` } case "too_small": { const n = lr(e.origin), i = t(e.origin, mr(Number(e.minimum)), e.inclusive ?? !1, "bigger"); if (i?.verb) return `${dr(n ?? e.origin ?? "reikšmė")} ${i.verb} ${e.minimum.toString()} ${i.unit ?? "elementų"}`; const r = e.inclusive ? "ne mažesnis kaip" : "didesnis kaip"; return `${dr(n ?? e.origin ?? "reikšmė")} turi būti ${r} ${e.minimum.toString()} ${i?.unit}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Eilutė privalo prasidėti "${t.prefix}"` : "ends_with" === t.format ? `Eilutė privalo pasibaigti "${t.suffix}"` : "includes" === t.format ? `Eilutė privalo įtraukti "${t.includes}"` : "regex" === t.format ? `Eilutė privalo atitikti ${t.pattern}` : `Neteisingas ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Skaičius privalo būti ${e.divisor} kartotinis.`; case "unrecognized_keys": return `Neatpažint${e.keys.length > 1 ? "i" : "as"} rakt${e.keys.length > 1 ? "ai" : "as"}: ${u(e.keys, ", ")}`; case "invalid_key": return "Rastas klaidingas raktas"; case "invalid_union": default: return "Klaidinga įvestis"; case "invalid_element": { const t = lr(e.origin); return `${dr(t ?? e.origin ?? "reikšmė")} turi klaidingą įvestį` } }var i } }; const fr = () => { const e = { string: { unit: "знаци", verb: "да имаат" }, file: { unit: "бајти", verb: "да имаат" }, array: { unit: "ставки", verb: "да имаат" }, set: { unit: "ставки", verb: "да имаат" } }; function t(t) { return e[t] ?? null } const n = { regex: "внес", email: "адреса на е-пошта", url: "URL", emoji: "емоџи", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO датум и време", date: "ISO датум", time: "ISO време", duration: "ISO времетраење", ipv4: "IPv4 адреса", ipv6: "IPv6 адреса", cidrv4: "IPv4 опсег", cidrv6: "IPv6 опсег", base64: "base64-енкодирана низа", base64url: "base64url-енкодирана низа", json_string: "JSON низа", e164: "E.164 број", jwt: "JWT", template_literal: "внес" }; return e => { switch (e.code) { case "invalid_type": return `Грешен внес: се очекува ${e.expected}, примено ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "број"; case "object": if (Array.isArray(e)) return "низа"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Invalid input: expected ${U(e.values[0])}` : `Грешана опција: се очекува една ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Премногу голем: се очекува ${e.origin ?? "вредноста"} да има ${n}${e.maximum.toString()} ${i.unit ?? "елементи"}` : `Премногу голем: се очекува ${e.origin ?? "вредноста"} да биде ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Премногу мал: се очекува ${e.origin} да има ${n}${e.minimum.toString()} ${i.unit}` : `Премногу мал: се очекува ${e.origin} да биде ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Неважечка низа: мора да започнува со "${t.prefix}"` : "ends_with" === t.format ? `Неважечка низа: мора да завршува со "${t.suffix}"` : "includes" === t.format ? `Неважечка низа: мора да вклучува "${t.includes}"` : "regex" === t.format ? `Неважечка низа: мора да одгоара на патернот ${t.pattern}` : `Invalid ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Грешен број: мора да биде делив со ${e.divisor}`; case "unrecognized_keys": return `${e.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Грешен клуч во ${e.origin}`; case "invalid_union": default: return "Грешен внес"; case "invalid_element": return `Грешна вредност во ${e.origin}` } } }; const vr = () => { const e = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } }; function t(t) { return e[t] ?? null } const n = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Input tidak sah: dijangka ${e.expected}, diterima ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "nombor"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Input tidak sah: dijangka ${U(e.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Terlalu besar: dijangka ${e.origin ?? "nilai"} ${i.verb} ${n}${e.maximum.toString()} ${i.unit ?? "elemen"}` : `Terlalu besar: dijangka ${e.origin ?? "nilai"} adalah ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Terlalu kecil: dijangka ${e.origin} ${i.verb} ${n}${e.minimum.toString()} ${i.unit}` : `Terlalu kecil: dijangka ${e.origin} adalah ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `String tidak sah: mesti bermula dengan "${t.prefix}"` : "ends_with" === t.format ? `String tidak sah: mesti berakhir dengan "${t.suffix}"` : "includes" === t.format ? `String tidak sah: mesti mengandungi "${t.includes}"` : "regex" === t.format ? `String tidak sah: mesti sepadan dengan corak ${t.pattern}` : `${n[t.format] ?? e.format} tidak sah` } case "not_multiple_of": return `Nombor tidak sah: perlu gandaan ${e.divisor}`; case "unrecognized_keys": return `Kunci tidak dikenali: ${u(e.keys, ", ")}`; case "invalid_key": return `Kunci tidak sah dalam ${e.origin}`; case "invalid_union": default: return "Input tidak sah"; case "invalid_element": return `Nilai tidak sah dalam ${e.origin}` } } }; const gr = () => { const e = { string: { unit: "tekens" }, file: { unit: "bytes" }, array: { unit: "elementen" }, set: { unit: "elementen" } }; function t(t) { return e[t] ?? null } const n = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }; return e => { switch (e.code) { case "invalid_type": return `Ongeldige invoer: verwacht ${e.expected}, ontving ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "getal"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Ongeldige invoer: verwacht ${U(e.values[0])}` : `Ongeldige optie: verwacht één van ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Te lang: verwacht dat ${e.origin ?? "waarde"} ${n}${e.maximum.toString()} ${i.unit ?? "elementen"} bevat` : `Te lang: verwacht dat ${e.origin ?? "waarde"} ${n}${e.maximum.toString()} is` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Te kort: verwacht dat ${e.origin} ${n}${e.minimum.toString()} ${i.unit} bevat` : `Te kort: verwacht dat ${e.origin} ${n}${e.minimum.toString()} is` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ongeldige tekst: moet met "${t.prefix}" beginnen` : "ends_with" === t.format ? `Ongeldige tekst: moet op "${t.suffix}" eindigen` : "includes" === t.format ? `Ongeldige tekst: moet "${t.includes}" bevatten` : "regex" === t.format ? `Ongeldige tekst: moet overeenkomen met patroon ${t.pattern}` : `Ongeldig: ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Ongeldig getal: moet een veelvoud van ${e.divisor} zijn`; case "unrecognized_keys": return `Onbekende key${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Ongeldige key in ${e.origin}`; case "invalid_union": default: return "Ongeldige invoer"; case "invalid_element": return `Ongeldige waarde in ${e.origin}` } } }; const hr = () => { const e = { string: { unit: "tegn", verb: "å ha" }, file: { unit: "bytes", verb: "å ha" }, array: { unit: "elementer", verb: "å inneholde" }, set: { unit: "elementer", verb: "å inneholde" } }; function t(t) { return e[t] ?? null } const n = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-område", ipv6: "IPv6-område", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `Ugyldig input: forventet ${e.expected}, fikk ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "tall"; case "object": if (Array.isArray(e)) return "liste"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Ugyldig verdi: forventet ${U(e.values[0])}` : `Ugyldig valg: forventet en av ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `For stor(t): forventet ${e.origin ?? "value"} til å ha ${n}${e.maximum.toString()} ${i.unit ?? "elementer"}` : `For stor(t): forventet ${e.origin ?? "value"} til å ha ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `For lite(n): forventet ${e.origin} til å ha ${n}${e.minimum.toString()} ${i.unit}` : `For lite(n): forventet ${e.origin} til å ha ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ugyldig streng: må starte med "${t.prefix}"` : "ends_with" === t.format ? `Ugyldig streng: må ende med "${t.suffix}"` : "includes" === t.format ? `Ugyldig streng: må inneholde "${t.includes}"` : "regex" === t.format ? `Ugyldig streng: må matche mønsteret ${t.pattern}` : `Ugyldig ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Ugyldig tall: må være et multiplum av ${e.divisor}`; case "unrecognized_keys": return `${e.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Ugyldig nøkkel i ${e.origin}`; case "invalid_union": default: return "Ugyldig input"; case "invalid_element": return `Ugyldig verdi i ${e.origin}` } } }; const $r = () => { const e = { string: { unit: "harf", verb: "olmalıdır" }, file: { unit: "bayt", verb: "olmalıdır" }, array: { unit: "unsur", verb: "olmalıdır" }, set: { unit: "unsur", verb: "olmalıdır" } }; function t(t) { return e[t] ?? null } const n = { regex: "giren", email: "epostagâh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengâmı", date: "ISO tarihi", time: "ISO zamanı", duration: "ISO müddeti", ipv4: "IPv4 nişânı", ipv6: "IPv6 nişânı", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-şifreli metin", base64url: "base64url-şifreli metin", json_string: "JSON metin", e164: "E.164 sayısı", jwt: "JWT", template_literal: "giren" }; return e => { switch (e.code) { case "invalid_type": return `Fâsit giren: umulan ${e.expected}, alınan ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "numara"; case "object": if (Array.isArray(e)) return "saf"; if (null === e) return "gayb"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Fâsit giren: umulan ${U(e.values[0])}` : `Fâsit tercih: mûteberler ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Fazla büyük: ${e.origin ?? "value"}, ${n}${e.maximum.toString()} ${i.unit ?? "elements"} sahip olmalıydı.` : `Fazla büyük: ${e.origin ?? "value"}, ${n}${e.maximum.toString()} olmalıydı.` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Fazla küçük: ${e.origin}, ${n}${e.minimum.toString()} ${i.unit} sahip olmalıydı.` : `Fazla küçük: ${e.origin}, ${n}${e.minimum.toString()} olmalıydı.` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Fâsit metin: "${t.prefix}" ile başlamalı.` : "ends_with" === t.format ? `Fâsit metin: "${t.suffix}" ile bitmeli.` : "includes" === t.format ? `Fâsit metin: "${t.includes}" ihtivâ etmeli.` : "regex" === t.format ? `Fâsit metin: ${t.pattern} nakşına uymalı.` : `Fâsit ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Fâsit sayı: ${e.divisor} katı olmalıydı.`; case "unrecognized_keys": return `Tanınmayan anahtar ${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `${e.origin} için tanınmayan anahtar var.`; case "invalid_union": return "Giren tanınamadı."; case "invalid_element": return `${e.origin} için tanınmayan kıymet var.`; default: return "Kıymet tanınamadı." } } }; const yr = () => { const e = { string: { unit: "توکي", verb: "ولري" }, file: { unit: "بایټس", verb: "ولري" }, array: { unit: "توکي", verb: "ولري" }, set: { unit: "توکي", verb: "ولري" } }; function t(t) { return e[t] ?? null } const n = { regex: "ورودي", email: "بریښنالیک", url: "یو آر ال", emoji: "ایموجي", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "نیټه او وخت", date: "نېټه", time: "وخت", duration: "موده", ipv4: "د IPv4 پته", ipv6: "د IPv6 پته", cidrv4: "د IPv4 ساحه", cidrv6: "د IPv6 ساحه", base64: "base64-encoded متن", base64url: "base64url-encoded متن", json_string: "JSON متن", e164: "د E.164 شمېره", jwt: "JWT", template_literal: "ورودي" }; return e => { switch (e.code) { case "invalid_type": return `ناسم ورودي: باید ${e.expected} وای, مګر ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "عدد"; case "object": if (Array.isArray(e)) return "ارې"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)} ترلاسه شو`; case "invalid_value": return 1 === e.values.length ? `ناسم ورودي: باید ${U(e.values[0])} وای` : `ناسم انتخاب: باید یو له ${u(e.values, "|")} څخه وای`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `ډیر لوی: ${e.origin ?? "ارزښت"} باید ${n}${e.maximum.toString()} ${i.unit ?? "عنصرونه"} ولري` : `ډیر لوی: ${e.origin ?? "ارزښت"} باید ${n}${e.maximum.toString()} وي` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `ډیر کوچنی: ${e.origin} باید ${n}${e.minimum.toString()} ${i.unit} ولري` : `ډیر کوچنی: ${e.origin} باید ${n}${e.minimum.toString()} وي` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `ناسم متن: باید د "${t.prefix}" سره پیل شي` : "ends_with" === t.format ? `ناسم متن: باید د "${t.suffix}" سره پای ته ورسيږي` : "includes" === t.format ? `ناسم متن: باید "${t.includes}" ولري` : "regex" === t.format ? `ناسم متن: باید د ${t.pattern} سره مطابقت ولري` : `${n[t.format] ?? e.format} ناسم دی` } case "not_multiple_of": return `ناسم عدد: باید د ${e.divisor} مضرب وي`; case "unrecognized_keys": return `ناسم ${e.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${u(e.keys, ", ")}`; case "invalid_key": return `ناسم کلیډ په ${e.origin} کې`; case "invalid_union": default: return "ناسمه ورودي"; case "invalid_element": return `ناسم عنصر په ${e.origin} کې` } } }; const _r = () => { const e = { string: { unit: "znaków", verb: "mieć" }, file: { unit: "bajtów", verb: "mieć" }, array: { unit: "elementów", verb: "mieć" }, set: { unit: "elementów", verb: "mieć" } }; function t(t) { return e[t] ?? null } const n = { regex: "wyrażenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "ciąg znaków zakodowany w formacie base64", base64url: "ciąg znaków zakodowany w formacie base64url", json_string: "ciąg znaków w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejście" }; return e => { switch (e.code) { case "invalid_type": return `Nieprawidłowe dane wejściowe: oczekiwano ${e.expected}, otrzymano ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "liczba"; case "object": if (Array.isArray(e)) return "tablica"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Nieprawidłowe dane wejściowe: oczekiwano ${U(e.values[0])}` : `Nieprawidłowa opcja: oczekiwano jednej z wartości ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Za duża wartość: oczekiwano, że ${e.origin ?? "wartość"} będzie mieć ${n}${e.maximum.toString()} ${i.unit ?? "elementów"}` : `Zbyt duż(y/a/e): oczekiwano, że ${e.origin ?? "wartość"} będzie wynosić ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Za mała wartość: oczekiwano, że ${e.origin ?? "wartość"} będzie mieć ${n}${e.minimum.toString()} ${i.unit ?? "elementów"}` : `Zbyt mał(y/a/e): oczekiwano, że ${e.origin ?? "wartość"} będzie wynosić ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Nieprawidłowy ciąg znaków: musi zaczynać się od "${t.prefix}"` : "ends_with" === t.format ? `Nieprawidłowy ciąg znaków: musi kończyć się na "${t.suffix}"` : "includes" === t.format ? `Nieprawidłowy ciąg znaków: musi zawierać "${t.includes}"` : "regex" === t.format ? `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${t.pattern}` : `Nieprawidłow(y/a/e) ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Nieprawidłowa liczba: musi być wielokrotnością ${e.divisor}`; case "unrecognized_keys": return `Nierozpoznane klucze${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Nieprawidłowy klucz w ${e.origin}`; case "invalid_union": default: return "Nieprawidłowe dane wejściowe"; case "invalid_element": return `Nieprawidłowa wartość w ${e.origin}` } } }; const br = () => { const e = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } }; function t(t) { return e[t] ?? null } const n = { regex: "padrão", email: "endereço de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "duração ISO", ipv4: "endereço IPv4", ipv6: "endereço IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "número E.164", jwt: "JWT", template_literal: "entrada" }; return e => { switch (e.code) { case "invalid_type": return `Tipo inválido: esperado ${e.expected}, recebido ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "número"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "nulo"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Entrada inválida: esperado ${U(e.values[0])}` : `Opção inválida: esperada uma das ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Muito grande: esperado que ${e.origin ?? "valor"} tivesse ${n}${e.maximum.toString()} ${i.unit ?? "elementos"}` : `Muito grande: esperado que ${e.origin ?? "valor"} fosse ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Muito pequeno: esperado que ${e.origin} tivesse ${n}${e.minimum.toString()} ${i.unit}` : `Muito pequeno: esperado que ${e.origin} fosse ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Texto inválido: deve começar com "${t.prefix}"` : "ends_with" === t.format ? `Texto inválido: deve terminar com "${t.suffix}"` : "includes" === t.format ? `Texto inválido: deve incluir "${t.includes}"` : "regex" === t.format ? `Texto inválido: deve corresponder ao padrão ${t.pattern}` : `${n[t.format] ?? e.format} inválido` } case "not_multiple_of": return `Número inválido: deve ser múltiplo de ${e.divisor}`; case "unrecognized_keys": return `Chave${e.keys.length > 1 ? "s" : ""} desconhecida${e.keys.length > 1 ? "s" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Chave inválida em ${e.origin}`; case "invalid_union": return "Entrada inválida"; case "invalid_element": return `Valor inválido em ${e.origin}`; default: return "Campo inválido" } } }; function kr(e, t, n, i) { const r = Math.abs(e), a = r % 10, o = r % 100; return o >= 11 && o <= 19 ? i : 1 === a ? t : a >= 2 && a <= 4 ? n : i } const Ir = () => { const e = { string: { unit: { one: "символ", few: "символа", many: "символов" }, verb: "иметь" }, file: { unit: { one: "байт", few: "байта", many: "байт" }, verb: "иметь" }, array: { unit: { one: "элемент", few: "элемента", many: "элементов" }, verb: "иметь" }, set: { unit: { one: "элемент", few: "элемента", many: "элементов" }, verb: "иметь" } }; function t(t) { return e[t] ?? null } const n = { regex: "ввод", email: "email адрес", url: "URL", emoji: "эмодзи", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO дата и время", date: "ISO дата", time: "ISO время", duration: "ISO длительность", ipv4: "IPv4 адрес", ipv6: "IPv6 адрес", cidrv4: "IPv4 диапазон", cidrv6: "IPv6 диапазон", base64: "строка в формате base64", base64url: "строка в формате base64url", json_string: "JSON строка", e164: "номер E.164", jwt: "JWT", template_literal: "ввод" }; return e => { switch (e.code) { case "invalid_type": return `Неверный ввод: ожидалось ${e.expected}, получено ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "число"; case "object": if (Array.isArray(e)) return "массив"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Неверный ввод: ожидалось ${U(e.values[0])}` : `Неверный вариант: ожидалось одно из ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); if (i) { const t = kr(Number(e.maximum), i.unit.one, i.unit.few, i.unit.many); return `Слишком большое значение: ожидалось, что ${e.origin ?? "значение"} будет иметь ${n}${e.maximum.toString()} ${t}` } return `Слишком большое значение: ожидалось, что ${e.origin ?? "значение"} будет ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); if (i) { const t = kr(Number(e.minimum), i.unit.one, i.unit.few, i.unit.many); return `Слишком маленькое значение: ожидалось, что ${e.origin} будет иметь ${n}${e.minimum.toString()} ${t}` } return `Слишком маленькое значение: ожидалось, что ${e.origin} будет ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Неверная строка: должна начинаться с "${t.prefix}"` : "ends_with" === t.format ? `Неверная строка: должна заканчиваться на "${t.suffix}"` : "includes" === t.format ? `Неверная строка: должна содержать "${t.includes}"` : "regex" === t.format ? `Неверная строка: должна соответствовать шаблону ${t.pattern}` : `Неверный ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Неверное число: должно быть кратным ${e.divisor}`; case "unrecognized_keys": return `Нераспознанн${e.keys.length > 1 ? "ые" : "ый"} ключ${e.keys.length > 1 ? "и" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Неверный ключ в ${e.origin}`; case "invalid_union": default: return "Неверные входные данные"; case "invalid_element": return `Неверное значение в ${e.origin}` } } }; const wr = () => { const e = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } }; function t(t) { return e[t] ?? null } const n = { regex: "vnos", email: "e-poštni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in čas", date: "ISO datum", time: "ISO čas", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 številka", jwt: "JWT", template_literal: "vnos" }; return e => { switch (e.code) { case "invalid_type": return `Neveljaven vnos: pričakovano ${e.expected}, prejeto ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "število"; case "object": if (Array.isArray(e)) return "tabela"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Neveljaven vnos: pričakovano ${U(e.values[0])}` : `Neveljavna možnost: pričakovano eno izmed ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Preveliko: pričakovano, da bo ${e.origin ?? "vrednost"} imelo ${n}${e.maximum.toString()} ${i.unit ?? "elementov"}` : `Preveliko: pričakovano, da bo ${e.origin ?? "vrednost"} ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Premajhno: pričakovano, da bo ${e.origin} imelo ${n}${e.minimum.toString()} ${i.unit}` : `Premajhno: pričakovano, da bo ${e.origin} ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Neveljaven niz: mora se začeti z "${t.prefix}"` : "ends_with" === t.format ? `Neveljaven niz: mora se končati z "${t.suffix}"` : "includes" === t.format ? `Neveljaven niz: mora vsebovati "${t.includes}"` : "regex" === t.format ? `Neveljaven niz: mora ustrezati vzorcu ${t.pattern}` : `Neveljaven ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Neveljavno število: mora biti večkratnik ${e.divisor}`; case "unrecognized_keys": return `Neprepoznan${e.keys.length > 1 ? "i ključi" : " ključ"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Neveljaven ključ v ${e.origin}`; case "invalid_union": default: return "Neveljaven vnos"; case "invalid_element": return `Neveljavna vrednost v ${e.origin}` } } }; const zr = () => { const e = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehålla" }, set: { unit: "objekt", verb: "att innehålla" } }; function t(t) { return e[t] ?? null } const n = { regex: "reguljärt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad sträng", base64url: "base64url-kodad sträng", json_string: "JSON-sträng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }; return e => { switch (e.code) { case "invalid_type": return `Ogiltig inmatning: förväntat ${e.expected}, fick ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "antal"; case "object": if (Array.isArray(e)) return "lista"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Ogiltig inmatning: förväntat ${U(e.values[0])}` : `Ogiltigt val: förväntade en av ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `För stor(t): förväntade ${e.origin ?? "värdet"} att ha ${n}${e.maximum.toString()} ${i.unit ?? "element"}` : `För stor(t): förväntat ${e.origin ?? "värdet"} att ha ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `För lite(t): förväntade ${e.origin ?? "värdet"} att ha ${n}${e.minimum.toString()} ${i.unit}` : `För lite(t): förväntade ${e.origin ?? "värdet"} att ha ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ogiltig sträng: måste börja med "${t.prefix}"` : "ends_with" === t.format ? `Ogiltig sträng: måste sluta med "${t.suffix}"` : "includes" === t.format ? `Ogiltig sträng: måste innehålla "${t.includes}"` : "regex" === t.format ? `Ogiltig sträng: måste matcha mönstret "${t.pattern}"` : `Ogiltig(t) ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Ogiltigt tal: måste vara en multipel av ${e.divisor}`; case "unrecognized_keys": return `${e.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${u(e.keys, ", ")}`; case "invalid_key": return `Ogiltig nyckel i ${e.origin ?? "värdet"}`; case "invalid_union": default: return "Ogiltig input"; case "invalid_element": return `Ogiltigt värde i ${e.origin ?? "värdet"}` } } }; const Sr = () => { const e = { string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" }, file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" }, array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }, set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" } }; function t(t) { return e[t] ?? null } const n = { regex: "உள்ளீடு", email: "மின்னஞ்சல் முகவரி", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO தேதி நேரம்", date: "ISO தேதி", time: "ISO நேரம்", duration: "ISO கால அளவு", ipv4: "IPv4 முகவரி", ipv6: "IPv6 முகவரி", cidrv4: "IPv4 வரம்பு", cidrv6: "IPv6 வரம்பு", base64: "base64-encoded சரம்", base64url: "base64url-encoded சரம்", json_string: "JSON சரம்", e164: "E.164 எண்", jwt: "JWT", template_literal: "input" }; return e => { switch (e.code) { case "invalid_type": return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${e.expected}, பெறப்பட்டது ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "எண் அல்லாதது" : "எண்"; case "object": if (Array.isArray(e)) return "அணி"; if (null === e) return "வெறுமை"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${U(e.values[0])}` : `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${u(e.values, "|")} இல் ஒன்று`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${e.origin ?? "மதிப்பு"} ${n}${e.maximum.toString()} ${i.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்` : `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${e.origin ?? "மதிப்பு"} ${n}${e.maximum.toString()} ஆக இருக்க வேண்டும்` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${e.origin} ${n}${e.minimum.toString()} ${i.unit} ஆக இருக்க வேண்டும்` : `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${e.origin} ${n}${e.minimum.toString()} ஆக இருக்க வேண்டும்` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `தவறான சரம்: "${t.prefix}" இல் தொடங்க வேண்டும்` : "ends_with" === t.format ? `தவறான சரம்: "${t.suffix}" இல் முடிவடைய வேண்டும்` : "includes" === t.format ? `தவறான சரம்: "${t.includes}" ஐ உள்ளடக்க வேண்டும்` : "regex" === t.format ? `தவறான சரம்: ${t.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்` : `தவறான ${n[t.format] ?? e.format}` } case "not_multiple_of": return `தவறான எண்: ${e.divisor} இன் பலமாக இருக்க வேண்டும்`; case "unrecognized_keys": return `அடையாளம் தெரியாத விசை${e.keys.length > 1 ? "கள்" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `${e.origin} இல் தவறான விசை`; case "invalid_union": default: return "தவறான உள்ளீடு"; case "invalid_element": return `${e.origin} இல் தவறான மதிப்பு` } } }; const xr = () => { const e = { string: { unit: "ตัวอักษร", verb: "ควรมี" }, file: { unit: "ไบต์", verb: "ควรมี" }, array: { unit: "รายการ", verb: "ควรมี" }, set: { unit: "รายการ", verb: "ควรมี" } }; function t(t) { return e[t] ?? null } const n = { regex: "ข้อมูลที่ป้อน", email: "ที่อยู่อีเมล", url: "URL", emoji: "อิโมจิ", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "วันที่เวลาแบบ ISO", date: "วันที่แบบ ISO", time: "เวลาแบบ ISO", duration: "ช่วงเวลาแบบ ISO", ipv4: "ที่อยู่ IPv4", ipv6: "ที่อยู่ IPv6", cidrv4: "ช่วง IP แบบ IPv4", cidrv6: "ช่วง IP แบบ IPv6", base64: "ข้อความแบบ Base64", base64url: "ข้อความแบบ Base64 สำหรับ URL", json_string: "ข้อความแบบ JSON", e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)", jwt: "โทเคน JWT", template_literal: "ข้อมูลที่ป้อน" }; return e => { switch (e.code) { case "invalid_type": return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${e.expected} แต่ได้รับ ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข"; case "object": if (Array.isArray(e)) return "อาร์เรย์ (Array)"; if (null === e) return "ไม่มีค่า (null)"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `ค่าไม่ถูกต้อง: ควรเป็น ${U(e.values[0])}` : `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "ไม่เกิน" : "น้อยกว่า", i = t(e.origin); return i ? `เกินกำหนด: ${e.origin ?? "ค่า"} ควรมี${n} ${e.maximum.toString()} ${i.unit ?? "รายการ"}` : `เกินกำหนด: ${e.origin ?? "ค่า"} ควรมี${n} ${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? "อย่างน้อย" : "มากกว่า", i = t(e.origin); return i ? `น้อยกว่ากำหนด: ${e.origin} ควรมี${n} ${e.minimum.toString()} ${i.unit}` : `น้อยกว่ากำหนด: ${e.origin} ควรมี${n} ${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${t.prefix}"` : "ends_with" === t.format ? `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${t.suffix}"` : "includes" === t.format ? `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${t.includes}" อยู่ในข้อความ` : "regex" === t.format ? `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${t.pattern}` : `รูปแบบไม่ถูกต้อง: ${n[t.format] ?? e.format}` } case "not_multiple_of": return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${e.divisor} ได้ลงตัว`; case "unrecognized_keys": return `พบคีย์ที่ไม่รู้จัก: ${u(e.keys, ", ")}`; case "invalid_key": return `คีย์ไม่ถูกต้องใน ${e.origin}`; case "invalid_union": return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้"; case "invalid_element": return `ข้อมูลไม่ถูกต้องใน ${e.origin}`; default: return "ข้อมูลไม่ถูกต้อง" } } }; const Or = () => { const e = { string: { unit: "karakter", verb: "olmalı" }, file: { unit: "bayt", verb: "olmalı" }, array: { unit: "öğe", verb: "olmalı" }, set: { unit: "öğe", verb: "olmalı" } }; function t(t) { return e[t] ?? null } const n = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO süre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aralığı", cidrv6: "IPv6 aralığı", base64: "base64 ile şifrelenmiş metin", base64url: "base64url ile şifrelenmiş metin", json_string: "JSON dizesi", e164: "E.164 sayısı", jwt: "JWT", template_literal: "Şablon dizesi" }; return e => { switch (e.code) { case "invalid_type": return `Geçersiz değer: beklenen ${e.expected}, alınan ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Geçersiz değer: beklenen ${U(e.values[0])}` : `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Çok büyük: beklenen ${e.origin ?? "değer"} ${n}${e.maximum.toString()} ${i.unit ?? "öğe"}` : `Çok büyük: beklenen ${e.origin ?? "değer"} ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Çok küçük: beklenen ${e.origin} ${n}${e.minimum.toString()} ${i.unit}` : `Çok küçük: beklenen ${e.origin} ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Geçersiz metin: "${t.prefix}" ile başlamalı` : "ends_with" === t.format ? `Geçersiz metin: "${t.suffix}" ile bitmeli` : "includes" === t.format ? `Geçersiz metin: "${t.includes}" içermeli` : "regex" === t.format ? `Geçersiz metin: ${t.pattern} desenine uymalı` : `Geçersiz ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Geçersiz sayı: ${e.divisor} ile tam bölünebilmeli`; case "unrecognized_keys": return `Tanınmayan anahtar${e.keys.length > 1 ? "lar" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `${e.origin} içinde geçersiz anahtar`; case "invalid_union": default: return "Geçersiz değer"; case "invalid_element": return `${e.origin} içinde geçersiz değer` } } }; const Ur = () => { const e = { string: { unit: "символів", verb: "матиме" }, file: { unit: "байтів", verb: "матиме" }, array: { unit: "елементів", verb: "матиме" }, set: { unit: "елементів", verb: "матиме" } }; function t(t) { return e[t] ?? null } const n = { regex: "вхідні дані", email: "адреса електронної пошти", url: "URL", emoji: "емодзі", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "дата та час ISO", date: "дата ISO", time: "час ISO", duration: "тривалість ISO", ipv4: "адреса IPv4", ipv6: "адреса IPv6", cidrv4: "діапазон IPv4", cidrv6: "діапазон IPv6", base64: "рядок у кодуванні base64", base64url: "рядок у кодуванні base64url", json_string: "рядок JSON", e164: "номер E.164", jwt: "JWT", template_literal: "вхідні дані" }; return e => { switch (e.code) { case "invalid_type": return `Неправильні вхідні дані: очікується ${e.expected}, отримано ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "число"; case "object": if (Array.isArray(e)) return "масив"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Неправильні вхідні дані: очікується ${U(e.values[0])}` : `Неправильна опція: очікується одне з ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Занадто велике: очікується, що ${e.origin ?? "значення"} ${i.verb} ${n}${e.maximum.toString()} ${i.unit ?? "елементів"}` : `Занадто велике: очікується, що ${e.origin ?? "значення"} буде ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Занадто мале: очікується, що ${e.origin} ${i.verb} ${n}${e.minimum.toString()} ${i.unit}` : `Занадто мале: очікується, що ${e.origin} буде ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Неправильний рядок: повинен починатися з "${t.prefix}"` : "ends_with" === t.format ? `Неправильний рядок: повинен закінчуватися на "${t.suffix}"` : "includes" === t.format ? `Неправильний рядок: повинен містити "${t.includes}"` : "regex" === t.format ? `Неправильний рядок: повинен відповідати шаблону ${t.pattern}` : `Неправильний ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Неправильне число: повинно бути кратним ${e.divisor}`; case "unrecognized_keys": return `Нерозпізнаний ключ${e.keys.length > 1 ? "і" : ""}: ${u(e.keys, ", ")}`; case "invalid_key": return `Неправильний ключ у ${e.origin}`; case "invalid_union": default: return "Неправильні вхідні дані"; case "invalid_element": return `Неправильне значення у ${e.origin}` } } }; function jr() { return { localeError: Ur() } } const Nr = () => { const e = { string: { unit: "حروف", verb: "ہونا" }, file: { unit: "بائٹس", verb: "ہونا" }, array: { unit: "آئٹمز", verb: "ہونا" }, set: { unit: "آئٹمز", verb: "ہونا" } }; function t(t) { return e[t] ?? null } const n = { regex: "ان پٹ", email: "ای میل ایڈریس", url: "یو آر ایل", emoji: "ایموجی", uuid: "یو یو آئی ڈی", uuidv4: "یو یو آئی ڈی وی 4", uuidv6: "یو یو آئی ڈی وی 6", nanoid: "نینو آئی ڈی", guid: "جی یو آئی ڈی", cuid: "سی یو آئی ڈی", cuid2: "سی یو آئی ڈی 2", ulid: "یو ایل آئی ڈی", xid: "ایکس آئی ڈی", ksuid: "کے ایس یو آئی ڈی", datetime: "آئی ایس او ڈیٹ ٹائم", date: "آئی ایس او تاریخ", time: "آئی ایس او وقت", duration: "آئی ایس او مدت", ipv4: "آئی پی وی 4 ایڈریس", ipv6: "آئی پی وی 6 ایڈریس", cidrv4: "آئی پی وی 4 رینج", cidrv6: "آئی پی وی 6 رینج", base64: "بیس 64 ان کوڈڈ سٹرنگ", base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ", json_string: "جے ایس او این سٹرنگ", e164: "ای 164 نمبر", jwt: "جے ڈبلیو ٹی", template_literal: "ان پٹ" }; return e => { switch (e.code) { case "invalid_type": return `غلط ان پٹ: ${e.expected} متوقع تھا، ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "نمبر"; case "object": if (Array.isArray(e)) return "آرے"; if (null === e) return "نل"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)} موصول ہوا`; case "invalid_value": return 1 === e.values.length ? `غلط ان پٹ: ${U(e.values[0])} متوقع تھا` : `غلط آپشن: ${u(e.values, "|")} میں سے ایک متوقع تھا`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `بہت بڑا: ${e.origin ?? "ویلیو"} کے ${n}${e.maximum.toString()} ${i.unit ?? "عناصر"} ہونے متوقع تھے` : `بہت بڑا: ${e.origin ?? "ویلیو"} کا ${n}${e.maximum.toString()} ہونا متوقع تھا` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `بہت چھوٹا: ${e.origin} کے ${n}${e.minimum.toString()} ${i.unit} ہونے متوقع تھے` : `بہت چھوٹا: ${e.origin} کا ${n}${e.minimum.toString()} ہونا متوقع تھا` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `غلط سٹرنگ: "${t.prefix}" سے شروع ہونا چاہیے` : "ends_with" === t.format ? `غلط سٹرنگ: "${t.suffix}" پر ختم ہونا چاہیے` : "includes" === t.format ? `غلط سٹرنگ: "${t.includes}" شامل ہونا چاہیے` : "regex" === t.format ? `غلط سٹرنگ: پیٹرن ${t.pattern} سے میچ ہونا چاہیے` : `غلط ${n[t.format] ?? e.format}` } case "not_multiple_of": return `غلط نمبر: ${e.divisor} کا مضاعف ہونا چاہیے`; case "unrecognized_keys": return `غیر تسلیم شدہ کی${e.keys.length > 1 ? "ز" : ""}: ${u(e.keys, "، ")}`; case "invalid_key": return `${e.origin} میں غلط کی`; case "invalid_union": default: return "غلط ان پٹ"; case "invalid_element": return `${e.origin} میں غلط ویلیو` } } }; const Dr = () => { const e = { string: { unit: "ký tự", verb: "có" }, file: { unit: "byte", verb: "có" }, array: { unit: "phần tử", verb: "có" }, set: { unit: "phần tử", verb: "có" } }; function t(t) { return e[t] ?? null } const n = { regex: "đầu vào", email: "địa chỉ email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngày giờ ISO", date: "ngày ISO", time: "giờ ISO", duration: "khoảng thời gian ISO", ipv4: "địa chỉ IPv4", ipv6: "địa chỉ IPv6", cidrv4: "dải IPv4", cidrv6: "dải IPv6", base64: "chuỗi mã hóa base64", base64url: "chuỗi mã hóa base64url", json_string: "chuỗi JSON", e164: "số E.164", jwt: "JWT", template_literal: "đầu vào" }; return e => { switch (e.code) { case "invalid_type": return `Đầu vào không hợp lệ: mong đợi ${e.expected}, nhận được ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "số"; case "object": if (Array.isArray(e)) return "mảng"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Đầu vào không hợp lệ: mong đợi ${U(e.values[0])}` : `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Quá lớn: mong đợi ${e.origin ?? "giá trị"} ${i.verb} ${n}${e.maximum.toString()} ${i.unit ?? "phần tử"}` : `Quá lớn: mong đợi ${e.origin ?? "giá trị"} ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Quá nhỏ: mong đợi ${e.origin} ${i.verb} ${n}${e.minimum.toString()} ${i.unit}` : `Quá nhỏ: mong đợi ${e.origin} ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Chuỗi không hợp lệ: phải bắt đầu bằng "${t.prefix}"` : "ends_with" === t.format ? `Chuỗi không hợp lệ: phải kết thúc bằng "${t.suffix}"` : "includes" === t.format ? `Chuỗi không hợp lệ: phải bao gồm "${t.includes}"` : "regex" === t.format ? `Chuỗi không hợp lệ: phải khớp với mẫu ${t.pattern}` : `${n[t.format] ?? e.format} không hợp lệ` } case "not_multiple_of": return `Số không hợp lệ: phải là bội số của ${e.divisor}`; case "unrecognized_keys": return `Khóa không được nhận dạng: ${u(e.keys, ", ")}`; case "invalid_key": return `Khóa không hợp lệ trong ${e.origin}`; case "invalid_union": default: return "Đầu vào không hợp lệ"; case "invalid_element": return `Giá trị không hợp lệ trong ${e.origin}` } } }; const Zr = () => { const e = { string: { unit: "字符", verb: "包含" }, file: { unit: "字节", verb: "包含" }, array: { unit: "项", verb: "包含" }, set: { unit: "项", verb: "包含" } }; function t(t) { return e[t] ?? null } const n = { regex: "输入", email: "电子邮件", url: "URL", emoji: "表情符号", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO日期时间", date: "ISO日期", time: "ISO时间", duration: "ISO时长", ipv4: "IPv4地址", ipv6: "IPv6地址", cidrv4: "IPv4网段", cidrv6: "IPv6网段", base64: "base64编码字符串", base64url: "base64url编码字符串", json_string: "JSON字符串", e164: "E.164号码", jwt: "JWT", template_literal: "输入" }; return e => { switch (e.code) { case "invalid_type": return `无效输入：期望 ${e.expected}，实际接收 ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "非数字(NaN)" : "数字"; case "object": if (Array.isArray(e)) return "数组"; if (null === e) return "空值(null)"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `无效输入：期望 ${U(e.values[0])}` : `无效选项：期望以下之一 ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `数值过大：期望 ${e.origin ?? "值"} ${n}${e.maximum.toString()} ${i.unit ?? "个元素"}` : `数值过大：期望 ${e.origin ?? "值"} ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `数值过小：期望 ${e.origin} ${n}${e.minimum.toString()} ${i.unit}` : `数值过小：期望 ${e.origin} ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `无效字符串：必须以 "${t.prefix}" 开头` : "ends_with" === t.format ? `无效字符串：必须以 "${t.suffix}" 结尾` : "includes" === t.format ? `无效字符串：必须包含 "${t.includes}"` : "regex" === t.format ? `无效字符串：必须满足正则表达式 ${t.pattern}` : `无效${n[t.format] ?? e.format}` } case "not_multiple_of": return `无效数字：必须是 ${e.divisor} 的倍数`; case "unrecognized_keys": return `出现未知的键(key): ${u(e.keys, ", ")}`; case "invalid_key": return `${e.origin} 中的键(key)无效`; case "invalid_union": default: return "无效输入"; case "invalid_element": return `${e.origin} 中包含无效值(value)` } } }; const Pr = () => { const e = { string: { unit: "字元", verb: "擁有" }, file: { unit: "位元組", verb: "擁有" }, array: { unit: "項目", verb: "擁有" }, set: { unit: "項目", verb: "擁有" } }; function t(t) { return e[t] ?? null } const n = { regex: "輸入", email: "郵件地址", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO 日期時間", date: "ISO 日期", time: "ISO 時間", duration: "ISO 期間", ipv4: "IPv4 位址", ipv6: "IPv6 位址", cidrv4: "IPv4 範圍", cidrv6: "IPv6 範圍", base64: "base64 編碼字串", base64url: "base64url 編碼字串", json_string: "JSON 字串", e164: "E.164 數值", jwt: "JWT", template_literal: "輸入" }; return e => { switch (e.code) { case "invalid_type": return `無效的輸入值：預期為 ${e.expected}，但收到 ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": if (Array.isArray(e)) return "array"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `無效的輸入值：預期為 ${U(e.values[0])}` : `無效的選項：預期為以下其中之一 ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `數值過大：預期 ${e.origin ?? "值"} 應為 ${n}${e.maximum.toString()} ${i.unit ?? "個元素"}` : `數值過大：預期 ${e.origin ?? "值"} 應為 ${n}${e.maximum.toString()}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `數值過小：預期 ${e.origin} 應為 ${n}${e.minimum.toString()} ${i.unit}` : `數值過小：預期 ${e.origin} 應為 ${n}${e.minimum.toString()}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `無效的字串：必須以 "${t.prefix}" 開頭` : "ends_with" === t.format ? `無效的字串：必須以 "${t.suffix}" 結尾` : "includes" === t.format ? `無效的字串：必須包含 "${t.includes}"` : "regex" === t.format ? `無效的字串：必須符合格式 ${t.pattern}` : `無效的 ${n[t.format] ?? e.format}` } case "not_multiple_of": return `無效的數字：必須為 ${e.divisor} 的倍數`; case "unrecognized_keys": return `無法識別的鍵值${e.keys.length > 1 ? "們" : ""}：${u(e.keys, "、")}`; case "invalid_key": return `${e.origin} 中有無效的鍵值`; case "invalid_union": default: return "無效的輸入值"; case "invalid_element": return `${e.origin} 中有無效的值` } } }; const Er = () => { const e = { string: { unit: "àmi", verb: "ní" }, file: { unit: "bytes", verb: "ní" }, array: { unit: "nkan", verb: "ní" }, set: { unit: "nkan", verb: "ní" } }; function t(t) { return e[t] ?? null } const n = { regex: "ẹ̀rọ ìbáwọlé", email: "àdírẹ́sì ìmẹ́lì", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "àkókò ISO", date: "ọjọ́ ISO", time: "àkókò ISO", duration: "àkókò tó pé ISO", ipv4: "àdírẹ́sì IPv4", ipv6: "àdírẹ́sì IPv6", cidrv4: "àgbègbè IPv4", cidrv6: "àgbègbè IPv6", base64: "ọ̀rọ̀ tí a kọ́ ní base64", base64url: "ọ̀rọ̀ base64url", json_string: "ọ̀rọ̀ JSON", e164: "nọ́mbà E.164", jwt: "JWT", template_literal: "ẹ̀rọ ìbáwọlé" }; return e => { switch (e.code) { case "invalid_type": return `Ìbáwọlé aṣìṣe: a ní láti fi ${e.expected}, àmọ̀ a rí ${(e => { const t = typeof e; switch (t) { case "number": return Number.isNaN(e) ? "NaN" : "nọ́mbà"; case "object": if (Array.isArray(e)) return "akopọ"; if (null === e) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name }return t })(e.input)}`; case "invalid_value": return 1 === e.values.length ? `Ìbáwọlé aṣìṣe: a ní láti fi ${U(e.values[0])}` : `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${u(e.values, "|")}`; case "too_big": { const n = e.inclusive ? "<=" : "<", i = t(e.origin); return i ? `Tó pọ̀ jù: a ní láti jẹ́ pé ${e.origin ?? "iye"} ${i.verb} ${n}${e.maximum} ${i.unit}` : `Tó pọ̀ jù: a ní láti jẹ́ ${n}${e.maximum}` } case "too_small": { const n = e.inclusive ? ">=" : ">", i = t(e.origin); return i ? `Kéré ju: a ní láti jẹ́ pé ${e.origin} ${i.verb} ${n}${e.minimum} ${i.unit}` : `Kéré ju: a ní láti jẹ́ ${n}${e.minimum}` } case "invalid_format": { const t = e; return "starts_with" === t.format ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${t.prefix}"` : "ends_with" === t.format ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${t.suffix}"` : "includes" === t.format ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${t.includes}"` : "regex" === t.format ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${t.pattern}` : `Aṣìṣe: ${n[t.format] ?? e.format}` } case "not_multiple_of": return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${e.divisor}`; case "unrecognized_keys": return `Bọtìnì àìmọ̀: ${u(e.keys, ", ")}`; case "invalid_key": return `Bọtìnì aṣìṣe nínú ${e.origin}`; case "invalid_union": default: return "Ìbáwọlé aṣìṣe"; case "invalid_element": return `Iye aṣìṣe nínú ${e.origin}` } } }; var Tr = Object.freeze({ __proto__: null, ar: function () { return { localeError: Ai() } }, az: function () { return { localeError: Li() } }, be: function () { return { localeError: Ri() } }, bg: function () { return { localeError: Fi() } }, ca: function () { return { localeError: Ji() } }, cs: function () { return { localeError: Mi() } }, da: function () { return { localeError: Wi() } }, de: function () { return { localeError: Gi() } }, en: Ki, eo: function () { return { localeError: Bi() } }, es: function () { return { localeError: Xi() } }, fa: function () { return { localeError: qi() } }, fi: function () { return { localeError: Yi() } }, fr: function () { return { localeError: Hi() } }, frCA: function () { return { localeError: Qi() } }, he: function () { return { localeError: er() } }, hu: function () { return { localeError: tr() } }, id: function () { return { localeError: nr() } }, is: function () { return { localeError: ir() } }, it: function () { return { localeError: rr() } }, ja: function () { return { localeError: ar() } }, ka: function () { return { localeError: or() } }, kh: function () { return ur() }, km: ur, ko: function () { return { localeError: cr() } }, lt: function () { return { localeError: pr() } }, mk: function () { return { localeError: fr() } }, ms: function () { return { localeError: vr() } }, nl: function () { return { localeError: gr() } }, no: function () { return { localeError: hr() } }, ota: function () { return { localeError: $r() } }, ps: function () { return { localeError: yr() } }, pl: function () { return { localeError: _r() } }, pt: function () { return { localeError: br() } }, ru: function () { return { localeError: Ir() } }, sl: function () { return { localeError: wr() } }, sv: function () { return { localeError: zr() } }, ta: function () { return { localeError: Sr() } }, th: function () { return { localeError: xr() } }, tr: function () { return { localeError: Or() } }, ua: function () { return jr() }, uk: jr, ur: function () { return { localeError: Nr() } }, vi: function () { return { localeError: Dr() } }, zhCN: function () { return { localeError: Zr() } }, zhTW: function () { return { localeError: Pr() } }, yo: function () { return { localeError: Er() } } }); const Ar = Symbol("ZodOutput"), Lr = Symbol("ZodInput"); class Cr { constructor() { this._map = new WeakMap, this._idmap = new Map } add(e, ...t) { const n = t[0]; if (this._map.set(e, n), n && "object" == typeof n && "id" in n) { if (this._idmap.has(n.id)) throw new Error(`ID ${n.id} already exists in the registry`); this._idmap.set(n.id, e) } return this } clear() { return this._map = new WeakMap, this._idmap = new Map, this } remove(e) { const t = this._map.get(e); return t && "object" == typeof t && "id" in t && this._idmap.delete(t.id), this._map.delete(e), this } get(e) { const t = e._zod.parent; if (t) { const n = { ...this.get(t) ?? {} }; delete n.id; const i = { ...n, ...this._map.get(e) }; return Object.keys(i).length ? i : void 0 } return this._map.get(e) } has(e) { return this._map.has(e) } } function Rr() { return new Cr } const Fr = Rr(); function Jr(e, t) { return new e({ type: "string", ...O(t) }) } function Mr(e, t) { return new e({ type: "string", coerce: !0, ...O(t) }) } function Wr(e, t) { return new e({ type: "string", format: "email", check: "string_format", abort: !1, ...O(t) }) } function Gr(e, t) { return new e({ type: "string", format: "guid", check: "string_format", abort: !1, ...O(t) }) } function Vr(e, t) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, ...O(t) }) } function Kr(e, t) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v4", ...O(t) }) } function Br(e, t) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v6", ...O(t) }) } function Xr(e, t) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v7", ...O(t) }) } function qr(e, t) { return new e({ type: "string", format: "url", check: "string_format", abort: !1, ...O(t) }) } function Yr(e, t) { return new e({ type: "string", format: "emoji", check: "string_format", abort: !1, ...O(t) }) } function Hr(e, t) { return new e({ type: "string", format: "nanoid", check: "string_format", abort: !1, ...O(t) }) } function Qr(e, t) { return new e({ type: "string", format: "cuid", check: "string_format", abort: !1, ...O(t) }) } function ea(e, t) { return new e({ type: "string", format: "cuid2", check: "string_format", abort: !1, ...O(t) }) } function ta(e, t) { return new e({ type: "string", format: "ulid", check: "string_format", abort: !1, ...O(t) }) } function na(e, t) { return new e({ type: "string", format: "xid", check: "string_format", abort: !1, ...O(t) }) } function ia(e, t) { return new e({ type: "string", format: "ksuid", check: "string_format", abort: !1, ...O(t) }) } function ra(e, t) { return new e({ type: "string", format: "ipv4", check: "string_format", abort: !1, ...O(t) }) } function aa(e, t) { return new e({ type: "string", format: "ipv6", check: "string_format", abort: !1, ...O(t) }) } function oa(e, t) { return new e({ type: "string", format: "cidrv4", check: "string_format", abort: !1, ...O(t) }) } function sa(e, t) { return new e({ type: "string", format: "cidrv6", check: "string_format", abort: !1, ...O(t) }) } function ua(e, t) { return new e({ type: "string", format: "base64", check: "string_format", abort: !1, ...O(t) }) } function ca(e, t) { return new e({ type: "string", format: "base64url", check: "string_format", abort: !1, ...O(t) }) } function la(e, t) { return new e({ type: "string", format: "e164", check: "string_format", abort: !1, ...O(t) }) } function da(e, t) { return new e({ type: "string", format: "jwt", check: "string_format", abort: !1, ...O(t) }) } const ma = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 }; function pa(e, t) { return new e({ type: "string", format: "datetime", check: "string_format", offset: !1, local: !1, precision: null, ...O(t) }) } function fa(e, t) { return new e({ type: "string", format: "date", check: "string_format", ...O(t) }) } function va(e, t) { return new e({ type: "string", format: "time", check: "string_format", precision: null, ...O(t) }) } function ga(e, t) { return new e({ type: "string", format: "duration", check: "string_format", ...O(t) }) } function ha(e, t) { return new e({ type: "number", checks: [], ...O(t) }) } function $a(e, t) { return new e({ type: "number", coerce: !0, checks: [], ...O(t) }) } function ya(e, t) { return new e({ type: "number", check: "number_format", abort: !1, format: "safeint", ...O(t) }) } function _a(e, t) { return new e({ type: "number", check: "number_format", abort: !1, format: "float32", ...O(t) }) } function ba(e, t) { return new e({ type: "number", check: "number_format", abort: !1, format: "float64", ...O(t) }) } function ka(e, t) { return new e({ type: "number", check: "number_format", abort: !1, format: "int32", ...O(t) }) } function Ia(e, t) { return new e({ type: "number", check: "number_format", abort: !1, format: "uint32", ...O(t) }) } function wa(e, t) { return new e({ type: "boolean", ...O(t) }) } function za(e, t) { return new e({ type: "boolean", coerce: !0, ...O(t) }) } function Sa(e, t) { return new e({ type: "bigint", ...O(t) }) } function xa(e, t) { return new e({ type: "bigint", coerce: !0, ...O(t) }) } function Oa(e, t) { return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "int64", ...O(t) }) } function Ua(e, t) { return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "uint64", ...O(t) }) } function ja(e, t) { return new e({ type: "symbol", ...O(t) }) } function Na(e, t) { return new e({ type: "undefined", ...O(t) }) } function Da(e, t) { return new e({ type: "null", ...O(t) }) } function Za(e) { return new e({ type: "any" }) } function Pa(e) { return new e({ type: "unknown" }) } function Ea(e, t) { return new e({ type: "never", ...O(t) }) } function Ta(e, t) { return new e({ type: "void", ...O(t) }) } function Aa(e, t) { return new e({ type: "date", ...O(t) }) } function La(e, t) { return new e({ type: "date", coerce: !0, ...O(t) }) } function Ca(e, t) { return new e({ type: "nan", ...O(t) }) } function Ra(e, t) { return new Ut({ check: "less_than", ...O(t), value: e, inclusive: !1 }) } function Fa(e, t) { return new Ut({ check: "less_than", ...O(t), value: e, inclusive: !0 }) } function Ja(e, t) { return new jt({ check: "greater_than", ...O(t), value: e, inclusive: !1 }) } function Ma(e, t) { return new jt({ check: "greater_than", ...O(t), value: e, inclusive: !0 }) } function Wa(e) { return Ja(0, e) } function Ga(e) { return Ra(0, e) } function Va(e) { return Fa(0, e) } function Ka(e) { return Ma(0, e) } function Ba(e, t) { return new Nt({ check: "multiple_of", ...O(t), value: e }) } function Xa(e, t) { return new Pt({ check: "max_size", ...O(t), maximum: e }) } function qa(e, t) { return new Et({ check: "min_size", ...O(t), minimum: e }) } function Ya(e, t) { return new Tt({ check: "size_equals", ...O(t), size: e }) } function Ha(e, t) { return new At({ check: "max_length", ...O(t), maximum: e }) } function Qa(e, t) { return new Lt({ check: "min_length", ...O(t), minimum: e }) } function eo(e, t) { return new Ct({ check: "length_equals", ...O(t), length: e }) } function to(e, t) { return new Ft({ check: "string_format", format: "regex", ...O(t), pattern: e }) } function no(e) { return new Jt({ check: "string_format", format: "lowercase", ...O(e) }) } function io(e) { return new Mt({ check: "string_format", format: "uppercase", ...O(e) }) } function ro(e, t) { return new Wt({ check: "string_format", format: "includes", ...O(t), includes: e }) } function ao(e, t) { return new Gt({ check: "string_format", format: "starts_with", ...O(t), prefix: e }) } function oo(e, t) { return new Vt({ check: "string_format", format: "ends_with", ...O(t), suffix: e }) } function so(e, t, n) { return new Bt({ check: "property", property: e, schema: t, ...O(n) }) } function uo(e, t) { return new Xt({ check: "mime_type", mime: e, ...O(t) }) } function co(e) { return new qt({ check: "overwrite", tx: e }) } function lo(e) { return co((t => t.normalize(e))) } function mo() { return co((e => e.trim())) } function po() { return co((e => e.toLowerCase())) } function fo() { return co((e => e.toUpperCase())) } function vo(e, t, n) { return new e({ type: "array", element: t, ...O(n) }) } function go(e, t) { return new e({ type: "file", ...O(t) }) } function ho(e, t, n) { const i = O(n); i.abort ?? (i.abort = !0); return new e({ type: "custom", check: "custom", fn: t, ...i }) } function $o(e, t, n) { return new e({ type: "custom", check: "custom", fn: t, ...O(n) }) } function yo(e) { const t = _o((n => (n.addIssue = e => { if ("string" == typeof e) n.issues.push(V(e, n.value, t._zod.def)); else { const i = e; i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = t), i.continue ?? (i.continue = !t._zod.def.abort), n.issues.push(V(i)) } }, e(n.value, n)))); return t } function _o(e, t) { const n = new xt({ check: "custom", ...O(t) }); return n._zod.check = e, n } function bo(e, t) { const n = O(t); let i = n.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], r = n.falsy ?? ["false", "0", "no", "off", "n", "disabled"]; "sensitive" !== n.case && (i = i.map((e => "string" == typeof e ? e.toLowerCase() : e)), r = r.map((e => "string" == typeof e ? e.toLowerCase() : e))); const a = new Set(i), o = new Set(r), s = e.Codec ?? Si, u = e.Boolean ?? Dn, c = new s({ type: "pipe", in: new (e.String ?? en)({ type: "string", error: n.error }), out: new u({ type: "boolean", error: n.error }), transform: (e, t) => { let i = e; return "sensitive" !== n.case && (i = i.toLowerCase()), !!a.has(i) || !o.has(i) && (t.issues.push({ code: "invalid_value", expected: "stringbool", values: [...a, ...o], input: t.value, inst: c, continue: !1 }), {}) }, reverseTransform: (e, t) => !0 === e ? i[0] || "true" : r[0] || "false", error: n.error }); return c } function ko(e, t, n, i = {}) { const r = O(i), a = { ...O(i), check: "string_format", type: "string", format: t, fn: "function" == typeof n ? n : e => n.test(e), ...r }; n instanceof RegExp && (a.pattern = n); return new e(a) } class Io { constructor(e) { this.counter = 0, this.metadataRegistry = e?.metadata ?? Fr, this.target = e?.target ?? "draft-2020-12", this.unrepresentable = e?.unrepresentable ?? "throw", this.override = e?.override ?? (() => { }), this.io = e?.io ?? "output", this.seen = new Map } process(e, t = { path: [], schemaPath: [] }) { var n; const i = e._zod.def, r = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, a = this.seen.get(e); if (a) { a.count++; return t.schemaPath.includes(e) && (a.cycle = t.path), a.schema } const o = { schema: {}, count: 1, cycle: void 0, path: t.path }; this.seen.set(e, o); const u = e._zod.toJSONSchema?.(); if (u) o.schema = u; else { const n = { ...t, schemaPath: [...t.schemaPath, e], path: t.path }, a = e._zod.parent; if (a) o.ref = a, this.process(a, n), this.seen.get(a).isParent = !0; else { const t = o.schema; switch (i.type) { case "string": { const n = t; n.type = "string"; const { minimum: i, maximum: a, format: s, patterns: u, contentEncoding: c } = e._zod.bag; if ("number" == typeof i && (n.minLength = i), "number" == typeof a && (n.maxLength = a), s && (n.format = r[s] ?? s, "" === n.format && delete n.format), c && (n.contentEncoding = c), u && u.size > 0) { const e = [...u]; 1 === e.length ? n.pattern = e[0].source : e.length > 1 && (o.schema.allOf = [...e.map((e => ({ ..."draft-7" === this.target || "draft-4" === this.target || "openapi-3.0" === this.target ? { type: "string" } : {}, pattern: e.source })))]) } break } case "number": { const n = t, { minimum: i, maximum: r, format: a, multipleOf: o, exclusiveMaximum: s, exclusiveMinimum: u } = e._zod.bag; "string" == typeof a && a.includes("int") ? n.type = "integer" : n.type = "number", "number" == typeof u && ("draft-4" === this.target || "openapi-3.0" === this.target ? (n.minimum = u, n.exclusiveMinimum = !0) : n.exclusiveMinimum = u), "number" == typeof i && (n.minimum = i, "number" == typeof u && "draft-4" !== this.target && (u >= i ? delete n.minimum : delete n.exclusiveMinimum)), "number" == typeof s && ("draft-4" === this.target || "openapi-3.0" === this.target ? (n.maximum = s, n.exclusiveMaximum = !0) : n.exclusiveMaximum = s), "number" == typeof r && (n.maximum = r, "number" == typeof s && "draft-4" !== this.target && (s <= r ? delete n.maximum : delete n.exclusiveMaximum)), "number" == typeof o && (n.multipleOf = o); break } case "boolean": t.type = "boolean"; break; case "bigint": if ("throw" === this.unrepresentable) throw new Error("BigInt cannot be represented in JSON Schema"); break; case "symbol": if ("throw" === this.unrepresentable) throw new Error("Symbols cannot be represented in JSON Schema"); break; case "null": "openapi-3.0" === this.target ? (t.type = "string", t.nullable = !0, t.enum = [null]) : t.type = "null"; break; case "any": case "unknown": break; case "undefined": if ("throw" === this.unrepresentable) throw new Error("Undefined cannot be represented in JSON Schema"); break; case "void": if ("throw" === this.unrepresentable) throw new Error("Void cannot be represented in JSON Schema"); break; case "never": t.not = {}; break; case "date": if ("throw" === this.unrepresentable) throw new Error("Date cannot be represented in JSON Schema"); break; case "array": { const r = t, { minimum: a, maximum: o } = e._zod.bag; "number" == typeof a && (r.minItems = a), "number" == typeof o && (r.maxItems = o), r.type = "array", r.items = this.process(i.element, { ...n, path: [...n.path, "items"] }); break } case "object": { const e = t; e.type = "object", e.properties = {}; const r = i.shape; for (const t in r) e.properties[t] = this.process(r[t], { ...n, path: [...n.path, "properties", t] }); const a = new Set(Object.keys(r)), o = new Set([...a].filter((e => { const t = i.shape[e]._zod; return "input" === this.io ? void 0 === t.optin : void 0 === t.optout }))); o.size > 0 && (e.required = Array.from(o)), "never" === i.catchall?._zod.def.type ? e.additionalProperties = !1 : i.catchall ? i.catchall && (e.additionalProperties = this.process(i.catchall, { ...n, path: [...n.path, "additionalProperties"] })) : "output" === this.io && (e.additionalProperties = !1); break } case "union": { const e = t, r = i.options.map(((e, t) => this.process(e, { ...n, path: [...n.path, "anyOf", t] }))); e.anyOf = r; break } case "intersection": { const e = t, r = this.process(i.left, { ...n, path: [...n.path, "allOf", 0] }), a = this.process(i.right, { ...n, path: [...n.path, "allOf", 1] }), o = e => "allOf" in e && 1 === Object.keys(e).length, s = [...o(r) ? r.allOf : [r], ...o(a) ? a.allOf : [a]]; e.allOf = s; break } case "tuple": { const r = t; r.type = "array"; const a = "draft-2020-12" === this.target ? "prefixItems" : "items", o = "draft-2020-12" === this.target || "openapi-3.0" === this.target ? "items" : "additionalItems", s = i.items.map(((e, t) => this.process(e, { ...n, path: [...n.path, a, t] }))), u = i.rest ? this.process(i.rest, { ...n, path: [...n.path, o, ..."openapi-3.0" === this.target ? [i.items.length] : []] }) : null; "draft-2020-12" === this.target ? (r.prefixItems = s, u && (r.items = u)) : "openapi-3.0" === this.target ? (r.items = { anyOf: s }, u && r.items.anyOf.push(u), r.minItems = s.length, u || (r.maxItems = s.length)) : (r.items = s, u && (r.additionalItems = u)); const { minimum: c, maximum: l } = e._zod.bag; "number" == typeof c && (r.minItems = c), "number" == typeof l && (r.maxItems = l); break } case "record": { const e = t; e.type = "object", "draft-7" !== this.target && "draft-2020-12" !== this.target || (e.propertyNames = this.process(i.keyType, { ...n, path: [...n.path, "propertyNames"] })), e.additionalProperties = this.process(i.valueType, { ...n, path: [...n.path, "additionalProperties"] }); break } case "map": if ("throw" === this.unrepresentable) throw new Error("Map cannot be represented in JSON Schema"); break; case "set": if ("throw" === this.unrepresentable) throw new Error("Set cannot be represented in JSON Schema"); break; case "enum": { const e = t, n = s(i.entries); n.every((e => "number" == typeof e)) && (e.type = "number"), n.every((e => "string" == typeof e)) && (e.type = "string"), e.enum = n; break } case "literal": { const e = t, n = []; for (const e of i.values) if (void 0 === e) { if ("throw" === this.unrepresentable) throw new Error("Literal `undefined` cannot be represented in JSON Schema") } else if ("bigint" == typeof e) { if ("throw" === this.unrepresentable) throw new Error("BigInt literals cannot be represented in JSON Schema"); n.push(Number(e)) } else n.push(e); if (0 === n.length); else if (1 === n.length) { const t = n[0]; e.type = null === t ? "null" : typeof t, "draft-4" === this.target || "openapi-3.0" === this.target ? e.enum = [t] : e.const = t } else n.every((e => "number" == typeof e)) && (e.type = "number"), n.every((e => "string" == typeof e)) && (e.type = "string"), n.every((e => "boolean" == typeof e)) && (e.type = "string"), n.every((e => null === e)) && (e.type = "null"), e.enum = n; break } case "file": { const n = t, i = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: r, maximum: a, mime: o } = e._zod.bag; void 0 !== r && (i.minLength = r), void 0 !== a && (i.maxLength = a), o ? 1 === o.length ? (i.contentMediaType = o[0], Object.assign(n, i)) : n.anyOf = o.map((e => ({ ...i, contentMediaType: e }))) : Object.assign(n, i); break } case "transform": if ("throw" === this.unrepresentable) throw new Error("Transforms cannot be represented in JSON Schema"); break; case "nullable": { const e = this.process(i.innerType, n); "openapi-3.0" === this.target ? (o.ref = i.innerType, t.nullable = !0) : t.anyOf = [e, { type: "null" }]; break } case "nonoptional": case "promise": case "optional": this.process(i.innerType, n), o.ref = i.innerType; break; case "success": t.type = "boolean"; break; case "default": this.process(i.innerType, n), o.ref = i.innerType, t.default = JSON.parse(JSON.stringify(i.defaultValue)); break; case "prefault": this.process(i.innerType, n), o.ref = i.innerType, "input" === this.io && (t._prefault = JSON.parse(JSON.stringify(i.defaultValue))); break; case "catch": { let e; this.process(i.innerType, n), o.ref = i.innerType; try { e = i.catchValue(void 0) } catch { throw new Error("Dynamic catch values are not supported in JSON Schema") } t.default = e; break } case "nan": if ("throw" === this.unrepresentable) throw new Error("NaN cannot be represented in JSON Schema"); break; case "template_literal": { const n = t, i = e._zod.pattern; if (!i) throw new Error("Pattern not found in template literal"); n.type = "string", n.pattern = i.source; break } case "pipe": { const e = "input" === this.io ? "transform" === i.in._zod.def.type ? i.out : i.in : i.out; this.process(e, n), o.ref = e; break } case "readonly": this.process(i.innerType, n), o.ref = i.innerType, t.readOnly = !0; break; case "lazy": { const t = e._zod.innerType; this.process(t, n), o.ref = t; break } case "custom": if ("throw" === this.unrepresentable) throw new Error("Custom types cannot be represented in JSON Schema"); break; case "function": if ("throw" === this.unrepresentable) throw new Error("Function types cannot be represented in JSON Schema") } } } const c = this.metadataRegistry.get(e); c && Object.assign(o.schema, c), "input" === this.io && zo(e) && (delete o.schema.examples, delete o.schema.default), "input" === this.io && o.schema._prefault && ((n = o.schema).default ?? (n.default = o.schema._prefault)), delete o.schema._prefault; return this.seen.get(e).schema } emit(e, t) { const n = { cycles: t?.cycles ?? "ref", reused: t?.reused ?? "inline", external: t?.external ?? void 0 }, i = this.seen.get(e); if (!i) throw new Error("Unprocessed schema. This is a bug in Zod."); const r = e => { const t = "draft-2020-12" === this.target ? "$defs" : "definitions"; if (n.external) { const i = n.external.registry.get(e[0])?.id, r = n.external.uri ?? (e => e); if (i) return { ref: r(i) }; const a = e[1].defId ?? e[1].schema.id ?? "schema" + this.counter++; return e[1].defId = a, { defId: a, ref: `${r("__shared")}#/${t}/${a}` } } if (e[1] === i) return { ref: "#" }; const r = `#/${t}/`, a = e[1].schema.id ?? "__schema" + this.counter++; return { defId: a, ref: r + a } }, a = e => { if (e[1].schema.$ref) return; const t = e[1], { ref: n, defId: i } = r(e); t.def = { ...t.schema }, i && (t.defId = i); const a = t.schema; for (const e in a) delete a[e]; a.$ref = n }; if ("throw" === n.cycles) for (const e of this.seen.entries()) { const t = e[1]; if (t.cycle) throw new Error(`Cycle detected: #/${t.cycle?.join("/")}/<root>\n\nSet the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`) } for (const t of this.seen.entries()) { const i = t[1]; if (e === t[0]) { a(t); continue } if (n.external) { const i = n.external.registry.get(t[0])?.id; if (e !== t[0] && i) { a(t); continue } } const r = this.metadataRegistry.get(t[0])?.id; r ? a(t) : (i.cycle || i.count > 1 && "ref" === n.reused) && a(t) } const o = (e, t) => { const n = this.seen.get(e), i = n.def ?? n.schema, r = { ...i }; if (null === n.ref) return; const a = n.ref; if (n.ref = null, a) { o(a, t); const e = this.seen.get(a).schema; !e.$ref || "draft-7" !== t.target && "draft-4" !== t.target && "openapi-3.0" !== t.target ? (Object.assign(i, e), Object.assign(i, r)) : (i.allOf = i.allOf ?? [], i.allOf.push(e)) } n.isParent || this.override({ zodSchema: e, jsonSchema: i, path: n.path ?? [] }) }; for (const e of [...this.seen.entries()].reverse()) o(e[0], { target: this.target }); const s = {}; if ("draft-2020-12" === this.target ? s.$schema = "https://json-schema.org/draft/2020-12/schema" : "draft-7" === this.target ? s.$schema = "http://json-schema.org/draft-07/schema#" : "draft-4" === this.target ? s.$schema = "http://json-schema.org/draft-04/schema#" : "openapi-3.0" === this.target || console.warn(`Invalid target: ${this.target}`), n.external?.uri) { const t = n.external.registry.get(e)?.id; if (!t) throw new Error("Schema is missing an `id` property"); s.$id = n.external.uri(t) } Object.assign(s, i.def); const u = n.external?.defs ?? {}; for (const e of this.seen.entries()) { const t = e[1]; t.def && t.defId && (u[t.defId] = t.def) } n.external || Object.keys(u).length > 0 && ("draft-2020-12" === this.target ? s.$defs = u : s.definitions = u); try { return JSON.parse(JSON.stringify(s)) } catch (e) { throw new Error("Error converting schema to JSON.") } } } function wo(e, t) { if (e instanceof Cr) { const n = new Io(t), i = {}; for (const t of e._idmap.entries()) { const [e, i] = t; n.process(i) } const r = {}, a = { registry: e, uri: t?.uri, defs: i }; for (const i of e._idmap.entries()) { const [e, o] = i; r[e] = n.emit(o, { ...t, external: a }) } if (Object.keys(i).length > 0) { const e = "draft-2020-12" === n.target ? "$defs" : "definitions"; r.__shared = { [e]: i } } return { schemas: r } } const n = new Io(t); return n.process(e), n.emit(e, t) } function zo(e, t) { const n = t ?? { seen: new Set }; if (n.seen.has(e)) return !1; n.seen.add(e); const i = e._zod.def; switch (i.type) { case "string": case "number": case "bigint": case "boolean": case "date": case "symbol": case "undefined": case "null": case "any": case "unknown": case "never": case "void": case "literal": case "enum": case "nan": case "file": case "template_literal": case "custom": case "success": case "catch": case "function": return !1; case "array": return zo(i.element, n); case "object": for (const e in i.shape) if (zo(i.shape[e], n)) return !0; return !1; case "union": for (const e of i.options) if (zo(e, n)) return !0; return !1; case "intersection": return zo(i.left, n) || zo(i.right, n); case "tuple": for (const e of i.items) if (zo(e, n)) return !0; return !(!i.rest || !zo(i.rest, n)); case "record": case "map": return zo(i.keyType, n) || zo(i.valueType, n); case "set": return zo(i.valueType, n); case "promise": case "optional": case "nonoptional": case "nullable": case "readonly": case "default": case "prefault": return zo(i.innerType, n); case "lazy": return zo(i.getter(), n); case "transform": return !0; case "pipe": return zo(i.in, n) || zo(i.out, n) }throw new Error(`Unknown schema type: ${i.type}`) } var So = Object.freeze({ __proto__: null }), xo = Object.freeze({ __proto__: null, util: X, regexes: St, locales: Tr, JSONSchema: So, NEVER: e, $constructor: t, $brand: n, $ZodAsyncError: i, $ZodEncodeError: r, globalConfig: a, config: o, _parse: re, parse: ae, _parseAsync: oe, parseAsync: se, _safeParse: ue, safeParse: ce, _safeParseAsync: le, safeParseAsync: de, _encode: me, encode: pe, _decode: fe, decode: ve, _encodeAsync: ge, encodeAsync: he, _decodeAsync: $e, decodeAsync: ye, _safeEncode: _e, safeEncode: be, _safeDecode: ke, safeDecode: Ie, _safeEncodeAsync: we, safeEncodeAsync: ze, _safeDecodeAsync: Se, safeDecodeAsync: xe, $ZodError: Y, $ZodRealError: H, flattenError: Q, formatError: ee, treeifyError: te, toDotPath: ne, prettifyError: ie, clone: x, $ZodType: Qt, $ZodString: en, $ZodStringFormat: tn, $ZodGUID: nn, $ZodUUID: rn, $ZodEmail: an, $ZodURL: on, $ZodEmoji: sn, $ZodNanoID: un, $ZodCUID: cn, $ZodCUID2: ln, $ZodULID: dn, $ZodXID: mn, $ZodKSUID: pn, $ZodISODateTime: fn, $ZodISODate: vn, $ZodISOTime: gn, $ZodISODuration: hn, $ZodIPv4: $n, $ZodIPv6: yn, $ZodCIDRv4: _n, $ZodCIDRv6: bn, isValidBase64: kn, $ZodBase64: In, isValidBase64URL: wn, $ZodBase64URL: zn, $ZodE164: Sn, isValidJWT: xn, $ZodJWT: On, $ZodCustomStringFormat: Un, $ZodNumber: jn, $ZodNumberFormat: Nn, $ZodBoolean: Dn, $ZodBigInt: Zn, $ZodBigIntFormat: Pn, $ZodSymbol: En, $ZodUndefined: Tn, $ZodNull: An, $ZodAny: Ln, $ZodUnknown: Cn, $ZodNever: Rn, $ZodVoid: Fn, $ZodDate: Jn, $ZodArray: Wn, $ZodObject: Bn, $ZodObjectJIT: Xn, $ZodUnion: Yn, $ZodDiscriminatedUnion: Hn, $ZodIntersection: Qn, $ZodTuple: ni, $ZodRecord: ri, $ZodMap: ai, $ZodSet: si, $ZodEnum: ci, $ZodLiteral: li, $ZodFile: di, $ZodTransform: mi, $ZodOptional: fi, $ZodNullable: vi, $ZodDefault: gi, $ZodPrefault: $i, $ZodNonOptional: yi, $ZodSuccess: bi, $ZodCatch: ki, $ZodNaN: Ii, $ZodPipe: wi, $ZodCodec: Si, $ZodReadonly: Ui, $ZodTemplateLiteral: Ni, $ZodFunction: Di, $ZodPromise: Zi, $ZodLazy: Pi, $ZodCustom: Ei, $ZodCheck: xt, $ZodCheckLessThan: Ut, $ZodCheckGreaterThan: jt, $ZodCheckMultipleOf: Nt, $ZodCheckNumberFormat: Dt, $ZodCheckBigIntFormat: Zt, $ZodCheckMaxSize: Pt, $ZodCheckMinSize: Et, $ZodCheckSizeEquals: Tt, $ZodCheckMaxLength: At, $ZodCheckMinLength: Lt, $ZodCheckLengthEquals: Ct, $ZodCheckStringFormat: Rt, $ZodCheckRegex: Ft, $ZodCheckLowerCase: Jt, $ZodCheckUpperCase: Mt, $ZodCheckIncludes: Wt, $ZodCheckStartsWith: Gt, $ZodCheckEndsWith: Vt, $ZodCheckProperty: Bt, $ZodCheckMimeType: Xt, $ZodCheckOverwrite: qt, version: Ht, $output: Ar, $input: Lr, $ZodRegistry: Cr, registry: Rr, globalRegistry: Fr, Doc: Yt, _string: Jr, _coercedString: Mr, _email: Wr, _guid: Gr, _uuid: Vr, _uuidv4: Kr, _uuidv6: Br, _uuidv7: Xr, _url: qr, _emoji: Yr, _nanoid: Hr, _cuid: Qr, _cuid2: ea, _ulid: ta, _xid: na, _ksuid: ia, _ipv4: ra, _ipv6: aa, _cidrv4: oa, _cidrv6: sa, _base64: ua, _base64url: ca, _e164: la, _jwt: da, TimePrecision: ma, _isoDateTime: pa, _isoDate: fa, _isoTime: va, _isoDuration: ga, _number: ha, _coercedNumber: $a, _int: ya, _float32: _a, _float64: ba, _int32: ka, _uint32: Ia, _boolean: wa, _coercedBoolean: za, _bigint: Sa, _coercedBigint: xa, _int64: Oa, _uint64: Ua, _symbol: ja, _undefined: Na, _null: Da, _any: Za, _unknown: Pa, _never: Ea, _void: Ta, _date: Aa, _coercedDate: La, _nan: Ca, _lt: Ra, _lte: Fa, _max: Fa, _gt: Ja, _gte: Ma, _min: Ma, _positive: Wa, _negative: Ga, _nonpositive: Va, _nonnegative: Ka, _multipleOf: Ba, _maxSize: Xa, _minSize: qa, _size: Ya, _maxLength: Ha, _minLength: Qa, _length: eo, _regex: to, _lowercase: no, _uppercase: io, _includes: ro, _startsWith: ao, _endsWith: oo, _property: so, _mime: uo, _overwrite: co, _normalize: lo, _trim: mo, _toLowerCase: po, _toUpperCase: fo, _array: vo, _union: function (e, t, n) { return new e({ type: "union", options: t, ...O(n) }) }, _discriminatedUnion: function (e, t, n, i) { return new e({ type: "union", options: n, discriminator: t, ...O(i) }) }, _intersection: function (e, t, n) { return new e({ type: "intersection", left: t, right: n }) }, _tuple: function (e, t, n, i) { const r = n instanceof Qt; return new e({ type: "tuple", items: t, rest: r ? n : null, ...O(r ? i : n) }) }, _record: function (e, t, n, i) { return new e({ type: "record", keyType: t, valueType: n, ...O(i) }) }, _map: function (e, t, n, i) { return new e({ type: "map", keyType: t, valueType: n, ...O(i) }) }, _set: function (e, t, n) { return new e({ type: "set", valueType: t, ...O(n) }) }, _enum: function (e, t, n) { return new e({ type: "enum", entries: Array.isArray(t) ? Object.fromEntries(t.map((e => [e, e]))) : t, ...O(n) }) }, _nativeEnum: function (e, t, n) { return new e({ type: "enum", entries: t, ...O(n) }) }, _literal: function (e, t, n) { return new e({ type: "literal", values: Array.isArray(t) ? t : [t], ...O(n) }) }, _file: go, _transform: function (e, t) { return new e({ type: "transform", transform: t }) }, _optional: function (e, t) { return new e({ type: "optional", innerType: t }) }, _nullable: function (e, t) { return new e({ type: "nullable", innerType: t }) }, _default: function (e, t, n) { return new e({ type: "default", innerType: t, get defaultValue() { return "function" == typeof n ? n() : I(n) } }) }, _nonoptional: function (e, t, n) { return new e({ type: "nonoptional", innerType: t, ...O(n) }) }, _success: function (e, t) { return new e({ type: "success", innerType: t }) }, _catch: function (e, t, n) { return new e({ type: "catch", innerType: t, catchValue: "function" == typeof n ? n : () => n }) }, _pipe: function (e, t, n) { return new e({ type: "pipe", in: t, out: n }) }, _readonly: function (e, t) { return new e({ type: "readonly", innerType: t }) }, _templateLiteral: function (e, t, n) { return new e({ type: "template_literal", parts: t, ...O(n) }) }, _lazy: function (e, t) { return new e({ type: "lazy", getter: t }) }, _promise: function (e, t) { return new e({ type: "promise", innerType: t }) }, _custom: ho, _refine: $o, _superRefine: yo, _check: _o, _stringbool: bo, _stringFormat: ko, JSONSchemaGenerator: Io, toJSONSchema: wo }); const Oo = t("ZodISODateTime", ((e, t) => { fn.init(e, t), ns.init(e, t) })); function Uo(e) { return pa(Oo, e) } const jo = t("ZodISODate", ((e, t) => { vn.init(e, t), ns.init(e, t) })); function No(e) { return fa(jo, e) } const Do = t("ZodISOTime", ((e, t) => { gn.init(e, t), ns.init(e, t) })); function Zo(e) { return va(Do, e) } const Po = t("ZodISODuration", ((e, t) => { hn.init(e, t), ns.init(e, t) })); function Eo(e) { return ga(Po, e) } var To = Object.freeze({ __proto__: null, ZodISODateTime: Oo, datetime: Uo, ZodISODate: jo, date: No, ZodISOTime: Do, time: Zo, ZodISODuration: Po, duration: Eo }); const Ao = (e, t) => { Y.init(e, t), e.name = "ZodError", Object.defineProperties(e, { format: { value: t => ee(e, t) }, flatten: { value: t => Q(e, t) }, addIssue: { value: t => { e.issues.push(t), e.message = JSON.stringify(e.issues, c, 2) } }, addIssues: { value: t => { e.issues.push(...t), e.message = JSON.stringify(e.issues, c, 2) } }, isEmpty: { get: () => 0 === e.issues.length } }) }, Lo = t("ZodError", Ao), Co = t("ZodError", Ao, { Parent: Error }), Ro = re(Co), Fo = oe(Co), Jo = ue(Co), Mo = le(Co), Wo = me(Co), Go = fe(Co), Vo = ge(Co), Ko = $e(Co), Bo = _e(Co), Xo = ke(Co), qo = we(Co), Yo = Se(Co), Ho = t("ZodType", ((e, t) => (Qt.init(e, t), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(h(t, { checks: [...t.checks ?? [], ...n.map((e => "function" == typeof e ? { _zod: { check: e, def: { check: "custom" }, onattach: [] } } : e))] })), e.clone = (t, n) => x(e, t, n), e.brand = () => e, e.register = (t, n) => (t.add(e, n), e), e.parse = (t, n) => Ro(e, t, n, { callee: e.parse }), e.safeParse = (t, n) => Jo(e, t, n), e.parseAsync = async (t, n) => Fo(e, t, n, { callee: e.parseAsync }), e.safeParseAsync = async (t, n) => Mo(e, t, n), e.spa = e.safeParseAsync, e.encode = (t, n) => Wo(e, t, n), e.decode = (t, n) => Go(e, t, n), e.encodeAsync = async (t, n) => Vo(e, t, n), e.decodeAsync = async (t, n) => Ko(e, t, n), e.safeEncode = (t, n) => Bo(e, t, n), e.safeDecode = (t, n) => Xo(e, t, n), e.safeEncodeAsync = async (t, n) => qo(e, t, n), e.safeDecodeAsync = async (t, n) => Yo(e, t, n), e.refine = (t, n) => e.check(Lc(t, n)), e.superRefine = t => e.check(Cc(t)), e.overwrite = t => e.check(co(t)), e.optional = () => ac(e), e.nullable = () => sc(e), e.nullish = () => ac(sc(e)), e.nonoptional = t => fc(e, t), e.array = () => Ou(e), e.or = t => Eu([e, t]), e.and = t => Cu(e, t), e.transform = t => kc(e, ic(t)), e.default = t => lc(e, t), e.prefault = t => mc(e, t), e.catch = t => $c(e, t), e.pipe = t => kc(e, t), e.readonly = () => Sc(e), e.describe = t => { const n = e.clone(); return Fr.add(n, { description: t }), n }, Object.defineProperty(e, "description", { get: () => Fr.get(e)?.description, configurable: !0 }), e.meta = (...t) => { if (0 === t.length) return Fr.get(e); const n = e.clone(); return Fr.add(n, t[0]), n }, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e))), Qo = t("_ZodString", ((e, t) => { en.init(e, t), Ho.init(e, t); const n = e._zod.bag; e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...t) => e.check(to(...t)), e.includes = (...t) => e.check(ro(...t)), e.startsWith = (...t) => e.check(ao(...t)), e.endsWith = (...t) => e.check(oo(...t)), e.min = (...t) => e.check(Qa(...t)), e.max = (...t) => e.check(Ha(...t)), e.length = (...t) => e.check(eo(...t)), e.nonempty = (...t) => e.check(Qa(1, ...t)), e.lowercase = t => e.check(no(t)), e.uppercase = t => e.check(io(t)), e.trim = () => e.check(mo()), e.normalize = (...t) => e.check(lo(...t)), e.toLowerCase = () => e.check(po()), e.toUpperCase = () => e.check(fo()) })), es = t("ZodString", ((e, t) => { en.init(e, t), Qo.init(e, t), e.email = t => e.check(Wr(is, t)), e.url = t => e.check(qr(ms, t)), e.jwt = t => e.check(da(Ms, t)), e.emoji = t => e.check(Yr(vs, t)), e.guid = t => e.check(Gr(as, t)), e.uuid = t => e.check(Vr(ss, t)), e.uuidv4 = t => e.check(Kr(ss, t)), e.uuidv6 = t => e.check(Br(ss, t)), e.uuidv7 = t => e.check(Xr(ss, t)), e.nanoid = t => e.check(Hr(hs, t)), e.guid = t => e.check(Gr(as, t)), e.cuid = t => e.check(Qr(ys, t)), e.cuid2 = t => e.check(ea(bs, t)), e.ulid = t => e.check(ta(Is, t)), e.base64 = t => e.check(ua(As, t)), e.base64url = t => e.check(ca(Cs, t)), e.xid = t => e.check(na(zs, t)), e.ksuid = t => e.check(ia(xs, t)), e.ipv4 = t => e.check(ra(Us, t)), e.ipv6 = t => e.check(aa(Ns, t)), e.cidrv4 = t => e.check(oa(Zs, t)), e.cidrv6 = t => e.check(sa(Es, t)), e.e164 = t => e.check(la(Fs, t)), e.datetime = t => e.check(Uo(t)), e.date = t => e.check(No(t)), e.time = t => e.check(Zo(t)), e.duration = t => e.check(Eo(t)) })); function ts(e) { return Jr(es, e) } const ns = t("ZodStringFormat", ((e, t) => { tn.init(e, t), Qo.init(e, t) })), is = t("ZodEmail", ((e, t) => { an.init(e, t), ns.init(e, t) })); function rs(e) { return Wr(is, e) } const as = t("ZodGUID", ((e, t) => { nn.init(e, t), ns.init(e, t) })); function os(e) { return Gr(as, e) } const ss = t("ZodUUID", ((e, t) => { rn.init(e, t), ns.init(e, t) })); function us(e) { return Vr(ss, e) } function cs(e) { return Kr(ss, e) } function ls(e) { return Br(ss, e) } function ds(e) { return Xr(ss, e) } const ms = t("ZodURL", ((e, t) => { on.init(e, t), ns.init(e, t) })); function ps(e) { return qr(ms, e) } function fs(e) { return qr(ms, { protocol: /^https?$/, hostname: Ye, ...O(e) }) } const vs = t("ZodEmoji", ((e, t) => { sn.init(e, t), ns.init(e, t) })); function gs(e) { return Yr(vs, e) } const hs = t("ZodNanoID", ((e, t) => { un.init(e, t), ns.init(e, t) })); function $s(e) { return Hr(hs, e) } const ys = t("ZodCUID", ((e, t) => { cn.init(e, t), ns.init(e, t) })); function _s(e) { return Qr(ys, e) } const bs = t("ZodCUID2", ((e, t) => { ln.init(e, t), ns.init(e, t) })); function ks(e) { return ea(bs, e) } const Is = t("ZodULID", ((e, t) => { dn.init(e, t), ns.init(e, t) })); function ws(e) { return ta(Is, e) } const zs = t("ZodXID", ((e, t) => { mn.init(e, t), ns.init(e, t) })); function Ss(e) { return na(zs, e) } const xs = t("ZodKSUID", ((e, t) => { pn.init(e, t), ns.init(e, t) })); function Os(e) { return ia(xs, e) } const Us = t("ZodIPv4", ((e, t) => { $n.init(e, t), ns.init(e, t) })); function js(e) { return ra(Us, e) } const Ns = t("ZodIPv6", ((e, t) => { yn.init(e, t), ns.init(e, t) })); function Ds(e) { return aa(Ns, e) } const Zs = t("ZodCIDRv4", ((e, t) => { _n.init(e, t), ns.init(e, t) })); function Ps(e) { return oa(Zs, e) } const Es = t("ZodCIDRv6", ((e, t) => { bn.init(e, t), ns.init(e, t) })); function Ts(e) { return sa(Es, e) } const As = t("ZodBase64", ((e, t) => { In.init(e, t), ns.init(e, t) })); function Ls(e) { return ua(As, e) } const Cs = t("ZodBase64URL", ((e, t) => { zn.init(e, t), ns.init(e, t) })); function Rs(e) { return ca(Cs, e) } const Fs = t("ZodE164", ((e, t) => { Sn.init(e, t), ns.init(e, t) })); function Js(e) { return la(Fs, e) } const Ms = t("ZodJWT", ((e, t) => { On.init(e, t), ns.init(e, t) })); function Ws(e) { return da(Ms, e) } const Gs = t("ZodCustomStringFormat", ((e, t) => { Un.init(e, t), ns.init(e, t) })); function Vs(e, t, n = {}) { return ko(Gs, e, t, n) } function Ks(e) { return ko(Gs, "hostname", qe, e) } function Bs(e) { return ko(Gs, "hex", pt, e) } function Xs(e, t) { const n = `${e}_${t?.enc ?? "hex"}`, i = St[n]; if (!i) throw new Error(`Unrecognized hash format: ${n}`); return ko(Gs, n, i, t) } const qs = t("ZodNumber", ((e, t) => { jn.init(e, t), Ho.init(e, t), e.gt = (t, n) => e.check(Ja(t, n)), e.gte = (t, n) => e.check(Ma(t, n)), e.min = (t, n) => e.check(Ma(t, n)), e.lt = (t, n) => e.check(Ra(t, n)), e.lte = (t, n) => e.check(Fa(t, n)), e.max = (t, n) => e.check(Fa(t, n)), e.int = t => e.check(Qs(t)), e.safe = t => e.check(Qs(t)), e.positive = t => e.check(Ja(0, t)), e.nonnegative = t => e.check(Ma(0, t)), e.negative = t => e.check(Ra(0, t)), e.nonpositive = t => e.check(Fa(0, t)), e.multipleOf = (t, n) => e.check(Ba(t, n)), e.step = (t, n) => e.check(Ba(t, n)), e.finite = () => e; const n = e._zod.bag; e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? .5), e.isFinite = !0, e.format = n.format ?? null })); function Ys(e) { return ha(qs, e) } const Hs = t("ZodNumberFormat", ((e, t) => { Nn.init(e, t), qs.init(e, t) })); function Qs(e) { return ya(Hs, e) } function eu(e) { return _a(Hs, e) } function tu(e) { return ba(Hs, e) } function nu(e) { return ka(Hs, e) } function iu(e) { return Ia(Hs, e) } const ru = t("ZodBoolean", ((e, t) => { Dn.init(e, t), Ho.init(e, t) })); function au(e) { return wa(ru, e) } const ou = t("ZodBigInt", ((e, t) => { Zn.init(e, t), Ho.init(e, t), e.gte = (t, n) => e.check(Ma(t, n)), e.min = (t, n) => e.check(Ma(t, n)), e.gt = (t, n) => e.check(Ja(t, n)), e.gte = (t, n) => e.check(Ma(t, n)), e.min = (t, n) => e.check(Ma(t, n)), e.lt = (t, n) => e.check(Ra(t, n)), e.lte = (t, n) => e.check(Fa(t, n)), e.max = (t, n) => e.check(Fa(t, n)), e.positive = t => e.check(Ja(BigInt(0), t)), e.negative = t => e.check(Ra(BigInt(0), t)), e.nonpositive = t => e.check(Fa(BigInt(0), t)), e.nonnegative = t => e.check(Ma(BigInt(0), t)), e.multipleOf = (t, n) => e.check(Ba(t, n)); const n = e._zod.bag; e.minValue = n.minimum ?? null, e.maxValue = n.maximum ?? null, e.format = n.format ?? null })); function su(e) { return Sa(ou, e) } const uu = t("ZodBigIntFormat", ((e, t) => { Pn.init(e, t), ou.init(e, t) })); function cu(e) { return Oa(uu, e) } function lu(e) { return Ua(uu, e) } const du = t("ZodSymbol", ((e, t) => { En.init(e, t), Ho.init(e, t) })); function mu(e) { return ja(du, e) } const pu = t("ZodUndefined", ((e, t) => { Tn.init(e, t), Ho.init(e, t) })); function fu(e) { return Na(pu, e) } const vu = t("ZodNull", ((e, t) => { An.init(e, t), Ho.init(e, t) })); function gu(e) { return Da(vu, e) } const hu = t("ZodAny", ((e, t) => { Ln.init(e, t), Ho.init(e, t) })); function $u() { return Za(hu) } const yu = t("ZodUnknown", ((e, t) => { Cn.init(e, t), Ho.init(e, t) })); function _u() { return Pa(yu) } const bu = t("ZodNever", ((e, t) => { Rn.init(e, t), Ho.init(e, t) })); function ku(e) { return Ea(bu, e) } const Iu = t("ZodVoid", ((e, t) => { Fn.init(e, t), Ho.init(e, t) })); function wu(e) { return Ta(Iu, e) } const zu = t("ZodDate", ((e, t) => { Jn.init(e, t), Ho.init(e, t), e.min = (t, n) => e.check(Ma(t, n)), e.max = (t, n) => e.check(Fa(t, n)); const n = e._zod.bag; e.minDate = n.minimum ? new Date(n.minimum) : null, e.maxDate = n.maximum ? new Date(n.maximum) : null })); function Su(e) { return Aa(zu, e) } const xu = t("ZodArray", ((e, t) => { Wn.init(e, t), Ho.init(e, t), e.element = t.element, e.min = (t, n) => e.check(Qa(t, n)), e.nonempty = t => e.check(Qa(1, t)), e.max = (t, n) => e.check(Ha(t, n)), e.length = (t, n) => e.check(eo(t, n)), e.unwrap = () => e.element })); function Ou(e, t) { return vo(xu, e, t) } function Uu(e) { const t = e._zod.def.shape; return qu(Object.keys(t)) } const ju = t("ZodObject", ((e, t) => { Xn.init(e, t), Ho.init(e, t), v(e, "shape", (() => t.shape)), e.keyof = () => qu(Object.keys(e._zod.def.shape)), e.catchall = t => e.clone({ ...e._zod.def, catchall: t }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: _u() }), e.loose = () => e.clone({ ...e._zod.def, catchall: _u() }), e.strict = () => e.clone({ ...e._zod.def, catchall: ku() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = t => E(e, t), e.safeExtend = t => T(e, t), e.merge = t => A(e, t), e.pick = t => Z(e, t), e.omit = t => P(e, t), e.partial = (...t) => L(rc, e, t[0]), e.required = (...t) => C(pc, e, t[0]) })); function Nu(e, t) { const n = { type: "object", shape: e ?? {}, ...O(t) }; return new ju(n) } function Du(e, t) { return new ju({ type: "object", shape: e, catchall: ku(), ...O(t) }) } function Zu(e, t) { return new ju({ type: "object", shape: e, catchall: _u(), ...O(t) }) } const Pu = t("ZodUnion", ((e, t) => { Yn.init(e, t), Ho.init(e, t), e.options = t.options })); function Eu(e, t) { return new Pu({ type: "union", options: e, ...O(t) }) } const Tu = t("ZodDiscriminatedUnion", ((e, t) => { Pu.init(e, t), Hn.init(e, t) })); function Au(e, t, n) { return new Tu({ type: "union", options: t, discriminator: e, ...O(n) }) } const Lu = t("ZodIntersection", ((e, t) => { Qn.init(e, t), Ho.init(e, t) })); function Cu(e, t) { return new Lu({ type: "intersection", left: e, right: t }) } const Ru = t("ZodTuple", ((e, t) => { ni.init(e, t), Ho.init(e, t), e.rest = t => e.clone({ ...e._zod.def, rest: t }) })); function Fu(e, t, n) { const i = t instanceof Qt; return new Ru({ type: "tuple", items: e, rest: i ? t : null, ...O(i ? n : t) }) } const Ju = t("ZodRecord", ((e, t) => { ri.init(e, t), Ho.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType })); function Mu(e, t, n) { return new Ju({ type: "record", keyType: e, valueType: t, ...O(n) }) } function Wu(e, t, n) { const i = x(e); return i._zod.values = void 0, new Ju({ type: "record", keyType: i, valueType: t, ...O(n) }) } const Gu = t("ZodMap", ((e, t) => { ai.init(e, t), Ho.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType })); function Vu(e, t, n) { return new Gu({ type: "map", keyType: e, valueType: t, ...O(n) }) } const Ku = t("ZodSet", ((e, t) => { si.init(e, t), Ho.init(e, t), e.min = (...t) => e.check(qa(...t)), e.nonempty = t => e.check(qa(1, t)), e.max = (...t) => e.check(Xa(...t)), e.size = (...t) => e.check(Ya(...t)) })); function Bu(e, t) { return new Ku({ type: "set", valueType: e, ...O(t) }) } const Xu = t("ZodEnum", ((e, t) => { ci.init(e, t), Ho.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries); const n = new Set(Object.keys(t.entries)); e.extract = (e, i) => { const r = {}; for (const i of e) { if (!n.has(i)) throw new Error(`Key ${i} not found in enum`); r[i] = t.entries[i] } return new Xu({ ...t, checks: [], ...O(i), entries: r }) }, e.exclude = (e, i) => { const r = { ...t.entries }; for (const t of e) { if (!n.has(t)) throw new Error(`Key ${t} not found in enum`); delete r[t] } return new Xu({ ...t, checks: [], ...O(i), entries: r }) } })); function qu(e, t) { const n = Array.isArray(e) ? Object.fromEntries(e.map((e => [e, e]))) : e; return new Xu({ type: "enum", entries: n, ...O(t) }) } function Yu(e, t) { return new Xu({ type: "enum", entries: e, ...O(t) }) } const Hu = t("ZodLiteral", ((e, t) => { li.init(e, t), Ho.init(e, t), e.values = new Set(t.values), Object.defineProperty(e, "value", { get() { if (t.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead."); return t.values[0] } }) })); function Qu(e, t) { return new Hu({ type: "literal", values: Array.isArray(e) ? e : [e], ...O(t) }) } const ec = t("ZodFile", ((e, t) => { di.init(e, t), Ho.init(e, t), e.min = (t, n) => e.check(qa(t, n)), e.max = (t, n) => e.check(Xa(t, n)), e.mime = (t, n) => e.check(uo(Array.isArray(t) ? t : [t], n)) })); function tc(e) { return go(ec, e) } const nc = t("ZodTransform", ((e, t) => { mi.init(e, t), Ho.init(e, t), e._zod.parse = (n, i) => { if ("backward" === i.direction) throw new r(e.constructor.name); n.addIssue = i => { if ("string" == typeof i) n.issues.push(V(i, n.value, t)); else { const t = i; t.fatal && (t.continue = !1), t.code ?? (t.code = "custom"), t.input ?? (t.input = n.value), t.inst ?? (t.inst = e), n.issues.push(V(t)) } }; const a = t.transform(n.value, n); return a instanceof Promise ? a.then((e => (n.value = e, n))) : (n.value = a, n) } })); function ic(e) { return new nc({ type: "transform", transform: e }) } const rc = t("ZodOptional", ((e, t) => { fi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function ac(e) { return new rc({ type: "optional", innerType: e }) } const oc = t("ZodNullable", ((e, t) => { vi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function sc(e) { return new oc({ type: "nullable", innerType: e }) } function uc(e) { return ac(sc(e)) } const cc = t("ZodDefault", ((e, t) => { gi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap })); function lc(e, t) { return new cc({ type: "default", innerType: e, get defaultValue() { return "function" == typeof t ? t() : I(t) } }) } const dc = t("ZodPrefault", ((e, t) => { $i.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function mc(e, t) { return new dc({ type: "prefault", innerType: e, get defaultValue() { return "function" == typeof t ? t() : I(t) } }) } const pc = t("ZodNonOptional", ((e, t) => { yi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function fc(e, t) { return new pc({ type: "nonoptional", innerType: e, ...O(t) }) } const vc = t("ZodSuccess", ((e, t) => { bi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function gc(e) { return new vc({ type: "success", innerType: e }) } const hc = t("ZodCatch", ((e, t) => { ki.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap })); function $c(e, t) { return new hc({ type: "catch", innerType: e, catchValue: "function" == typeof t ? t : () => t }) } const yc = t("ZodNaN", ((e, t) => { Ii.init(e, t), Ho.init(e, t) })); function _c(e) { return Ca(yc, e) } const bc = t("ZodPipe", ((e, t) => { wi.init(e, t), Ho.init(e, t), e.in = t.in, e.out = t.out })); function kc(e, t) { return new bc({ type: "pipe", in: e, out: t }) } const Ic = t("ZodCodec", ((e, t) => { bc.init(e, t), Si.init(e, t) })); function wc(e, t, n) { return new Ic({ type: "pipe", in: e, out: t, transform: n.decode, reverseTransform: n.encode }) } const zc = t("ZodReadonly", ((e, t) => { Ui.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function Sc(e) { return new zc({ type: "readonly", innerType: e }) } const xc = t("ZodTemplateLiteral", ((e, t) => { Ni.init(e, t), Ho.init(e, t) })); function Oc(e, t) { return new xc({ type: "template_literal", parts: e, ...O(t) }) } const Uc = t("ZodLazy", ((e, t) => { Pi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.getter() })); function jc(e) { return new Uc({ type: "lazy", getter: e }) } const Nc = t("ZodPromise", ((e, t) => { Zi.init(e, t), Ho.init(e, t), e.unwrap = () => e._zod.def.innerType })); function Dc(e) { return new Nc({ type: "promise", innerType: e }) } const Zc = t("ZodFunction", ((e, t) => { Di.init(e, t), Ho.init(e, t) })); function Pc(e) { return new Zc({ type: "function", input: Array.isArray(e?.input) ? Fu(e?.input) : e?.input ?? Ou(_u()), output: e?.output ?? _u() }) } const Ec = t("ZodCustom", ((e, t) => { Ei.init(e, t), Ho.init(e, t) })); function Tc(e) { const t = new xt({ check: "custom" }); return t._zod.check = e, t } function Ac(e, t) { return ho(Ec, e ?? (() => !0), t) } function Lc(e, t = {}) { return $o(Ec, e, t) } function Cc(e) { return yo(e) } function Rc(e, t = { error: `Input not instance of ${e.name}` }) { const n = new Ec({ type: "custom", check: "custom", fn: t => t instanceof e, abort: !0, ...O(t) }); return n._zod.bag.Class = e, n } const Fc = (...e) => bo({ Codec: Ic, Boolean: ru, String: es }, ...e); function Jc(e) { const t = jc((() => Eu([ts(e), Ys(), au(), gu(), Ou(t), Mu(ts(), t)]))); return t } function Mc(e, t) { return kc(ic(e), t) } const Wc = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" }; function Gc(e) { o({ customError: e }) } function Vc() { return o().customError } var Kc; Kc || (Kc = {}); var Bc = Object.freeze({ __proto__: null, string: function (e) { return Mr(es, e) }, number: function (e) { return $a(qs, e) }, boolean: function (e) { return za(ru, e) }, bigint: function (e) { return xa(ou, e) }, date: function (e) { return La(zu, e) } }); o(Ki()); var Xc = Object.freeze({ __proto__: null, core: xo, globalRegistry: Fr, registry: Rr, config: o, $output: Ar, $input: Lr, $brand: n, clone: x, regexes: St, treeifyError: te, prettifyError: ie, formatError: ee, flattenError: Q, toJSONSchema: wo, TimePrecision: ma, util: X, NEVER: e, locales: Tr, ZodISODateTime: Oo, ZodISODate: jo, ZodISOTime: Do, ZodISODuration: Po, iso: To, coerce: Bc, ZodType: Ho, _ZodString: Qo, ZodString: es, string: ts, ZodStringFormat: ns, ZodEmail: is, email: rs, ZodGUID: as, guid: os, ZodUUID: ss, uuid: us, uuidv4: cs, uuidv6: ls, uuidv7: ds, ZodURL: ms, url: ps, httpUrl: fs, ZodEmoji: vs, emoji: gs, ZodNanoID: hs, nanoid: $s, ZodCUID: ys, cuid: _s, ZodCUID2: bs, cuid2: ks, ZodULID: Is, ulid: ws, ZodXID: zs, xid: Ss, ZodKSUID: xs, ksuid: Os, ZodIPv4: Us, ipv4: js, ZodIPv6: Ns, ipv6: Ds, ZodCIDRv4: Zs, cidrv4: Ps, ZodCIDRv6: Es, cidrv6: Ts, ZodBase64: As, base64: Ls, ZodBase64URL: Cs, base64url: Rs, ZodE164: Fs, e164: Js, ZodJWT: Ms, jwt: Ws, ZodCustomStringFormat: Gs, stringFormat: Vs, hostname: Ks, hex: Bs, hash: Xs, ZodNumber: qs, number: Ys, ZodNumberFormat: Hs, int: Qs, float32: eu, float64: tu, int32: nu, uint32: iu, ZodBoolean: ru, boolean: au, ZodBigInt: ou, bigint: su, ZodBigIntFormat: uu, int64: cu, uint64: lu, ZodSymbol: du, symbol: mu, ZodUndefined: pu, undefined: fu, ZodNull: vu, null: gu, ZodAny: hu, any: $u, ZodUnknown: yu, unknown: _u, ZodNever: bu, never: ku, ZodVoid: Iu, void: wu, ZodDate: zu, date: Su, ZodArray: xu, array: Ou, keyof: Uu, ZodObject: ju, object: Nu, strictObject: Du, looseObject: Zu, ZodUnion: Pu, union: Eu, ZodDiscriminatedUnion: Tu, discriminatedUnion: Au, ZodIntersection: Lu, intersection: Cu, ZodTuple: Ru, tuple: Fu, ZodRecord: Ju, record: Mu, partialRecord: Wu, ZodMap: Gu, map: Vu, ZodSet: Ku, set: Bu, ZodEnum: Xu, enum: qu, nativeEnum: Yu, ZodLiteral: Hu, literal: Qu, ZodFile: ec, file: tc, ZodTransform: nc, transform: ic, ZodOptional: rc, optional: ac, ZodNullable: oc, nullable: sc, nullish: uc, ZodDefault: cc, _default: lc, ZodPrefault: dc, prefault: mc, ZodNonOptional: pc, nonoptional: fc, ZodSuccess: vc, success: gc, ZodCatch: hc, catch: $c, ZodNaN: yc, nan: _c, ZodPipe: bc, pipe: kc, ZodCodec: Ic, codec: wc, ZodReadonly: zc, readonly: Sc, ZodTemplateLiteral: xc, templateLiteral: Oc, ZodLazy: Uc, lazy: jc, ZodPromise: Nc, promise: Dc, ZodFunction: Zc, _function: Pc, function: Pc, ZodCustom: Ec, check: Tc, custom: Ac, refine: Lc, superRefine: Cc, instanceof: Rc, stringbool: Fc, json: Jc, preprocess: Mc, lt: Ra, lte: Fa, gt: Ja, gte: Ma, positive: Wa, negative: Ga, nonpositive: Va, nonnegative: Ka, multipleOf: Ba, maxSize: Xa, minSize: qa, size: Ya, maxLength: Ha, minLength: Qa, length: eo, regex: to, lowercase: no, uppercase: io, includes: ro, startsWith: ao, endsWith: oo, property: so, mime: uo, overwrite: co, normalize: lo, trim: mo, toLowerCase: po, toUpperCase: fo, ZodError: Lo, ZodRealError: Co, parse: Ro, parseAsync: Fo, safeParse: Jo, safeParseAsync: Mo, encode: Wo, decode: Go, encodeAsync: Vo, decodeAsync: Ko, safeEncode: Bo, safeDecode: Xo, safeEncodeAsync: qo, safeDecodeAsync: Yo, ZodIssueCode: Wc, setErrorMap: Gc, getErrorMap: Vc, get ZodFirstPartyTypeKind() { return Kc } }); export { n as $brand, Lr as $input, Ar as $output, e as NEVER, ma as TimePrecision, hu as ZodAny, xu as ZodArray, As as ZodBase64, Cs as ZodBase64URL, ou as ZodBigInt, uu as ZodBigIntFormat, ru as ZodBoolean, Zs as ZodCIDRv4, Es as ZodCIDRv6, ys as ZodCUID, bs as ZodCUID2, hc as ZodCatch, Ic as ZodCodec, Ec as ZodCustom, Gs as ZodCustomStringFormat, zu as ZodDate, cc as ZodDefault, Tu as ZodDiscriminatedUnion, Fs as ZodE164, is as ZodEmail, vs as ZodEmoji, Xu as ZodEnum, Lo as ZodError, ec as ZodFile, Kc as ZodFirstPartyTypeKind, Zc as ZodFunction, as as ZodGUID, Us as ZodIPv4, Ns as ZodIPv6, jo as ZodISODate, Oo as ZodISODateTime, Po as ZodISODuration, Do as ZodISOTime, Lu as ZodIntersection, Wc as ZodIssueCode, Ms as ZodJWT, xs as ZodKSUID, Uc as ZodLazy, Hu as ZodLiteral, Gu as ZodMap, yc as ZodNaN, hs as ZodNanoID, bu as ZodNever, pc as ZodNonOptional, vu as ZodNull, oc as ZodNullable, qs as ZodNumber, Hs as ZodNumberFormat, ju as ZodObject, rc as ZodOptional, bc as ZodPipe, dc as ZodPrefault, Nc as ZodPromise, zc as ZodReadonly, Co as ZodRealError, Ju as ZodRecord, Ku as ZodSet, es as ZodString, ns as ZodStringFormat, vc as ZodSuccess, du as ZodSymbol, xc as ZodTemplateLiteral, nc as ZodTransform, Ru as ZodTuple, Ho as ZodType, Is as ZodULID, ms as ZodURL, ss as ZodUUID, pu as ZodUndefined, Pu as ZodUnion, yu as ZodUnknown, Iu as ZodVoid, zs as ZodXID, Qo as _ZodString, lc as _default, Pc as _function, $u as any, Ou as array, Ls as base64, Rs as base64url, su as bigint, au as boolean, $c as catch, Tc as check, Ps as cidrv4, Ts as cidrv6, x as clone, wc as codec, Bc as coerce, o as config, xo as core, _s as cuid, ks as cuid2, Ac as custom, Su as date, Go as decode, Ko as decodeAsync, Xc as default, Au as discriminatedUnion, Js as e164, rs as email, gs as emoji, Wo as encode, Vo as encodeAsync, oo as endsWith, qu as enum, tc as file, Q as flattenError, eu as float32, tu as float64, ee as formatError, Pc as function, Vc as getErrorMap, Fr as globalRegistry, Ja as gt, Ma as gte, os as guid, Xs as hash, Bs as hex, Ks as hostname, fs as httpUrl, ro as includes, Rc as instanceof, Qs as int, nu as int32, cu as int64, Cu as intersection, js as ipv4, Ds as ipv6, To as iso, Jc as json, Ws as jwt, Uu as keyof, Os as ksuid, jc as lazy, eo as length, Qu as literal, Tr as locales, Zu as looseObject, no as lowercase, Ra as lt, Fa as lte, Vu as map, Ha as maxLength, Xa as maxSize, uo as mime, Qa as minLength, qa as minSize, Ba as multipleOf, _c as nan, $s as nanoid, Yu as nativeEnum, Ga as negative, ku as never, Ka as nonnegative, fc as nonoptional, Va as nonpositive, lo as normalize, gu as null, sc as nullable, uc as nullish, Ys as number, Nu as object, ac as optional, co as overwrite, Ro as parse, Fo as parseAsync, Wu as partialRecord, kc as pipe, Wa as positive, mc as prefault, Mc as preprocess, ie as prettifyError, Dc as promise, so as property, Sc as readonly, Mu as record, Lc as refine, to as regex, St as regexes, Rr as registry, Xo as safeDecode, Yo as safeDecodeAsync, Bo as safeEncode, qo as safeEncodeAsync, Jo as safeParse, Mo as safeParseAsync, Bu as set, Gc as setErrorMap, Ya as size, ao as startsWith, Du as strictObject, ts as string, Vs as stringFormat, Fc as stringbool, gc as success, Cc as superRefine, mu as symbol, Oc as templateLiteral, wo as toJSONSchema, po as toLowerCase, fo as toUpperCase, ic as transform, te as treeifyError, mo as trim, Fu as tuple, iu as uint32, lu as uint64, ws as ulid, fu as undefined, Eu as union, _u as unknown, io as uppercase, ps as url, X as util, us as uuid, cs as uuidv4, ls as uuidv6, ds as uuidv7, wu as void, Ss as xid, Xc as z };
//# sourceMappingURL=/sm/78b7b7e0d14b8d24350a4a4d5b14819080bfd5755da26e92d1c2a5efb492bd5b.map
